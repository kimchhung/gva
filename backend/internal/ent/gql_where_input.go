// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/gva/app/database/schema/xid"
	"github.com/gva/internal/ent/admin"
	"github.com/gva/internal/ent/permission"
	"github.com/gva/internal/ent/predicate"
	"github.com/gva/internal/ent/role"
	"github.com/gva/internal/ent/route"
)

// AdminWhereInput represents a where input for filtering Admin queries.
type AdminWhereInput struct {
	Predicates []predicate.Admin  `json:"-"`
	Not        *AdminWhereInput   `json:"not,omitempty"`
	Or         []*AdminWhereInput `json:"or,omitempty"`
	And        []*AdminWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AdminWhereInput) AddPredicates(predicates ...predicate.Admin) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AdminWhereInput filter on the AdminQuery builder.
func (i *AdminWhereInput) Filter(q *AdminQuery) (*AdminQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAdminWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAdminWhereInput is returned in case the AdminWhereInput is empty.
var ErrEmptyAdminWhereInput = errors.New("ent: empty predicate AdminWhereInput")

// P returns a predicate for filtering admins.
// An error is returned if the input is empty or invalid.
func (i *AdminWhereInput) P() (predicate.Admin, error) {
	var predicates []predicate.Admin
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, admin.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Admin, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, admin.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Admin, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, admin.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, admin.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, admin.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, admin.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, admin.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, admin.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, admin.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, admin.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, admin.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, admin.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, admin.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, admin.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, admin.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, admin.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, admin.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, admin.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, admin.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, admin.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, admin.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, admin.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, admin.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, admin.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, admin.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, admin.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, admin.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, admin.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, admin.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, admin.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, admin.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, admin.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, admin.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, admin.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, admin.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, admin.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, admin.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, admin.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, admin.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, admin.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, admin.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, admin.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, admin.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, admin.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, admin.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, admin.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, admin.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, admin.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, admin.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, admin.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, admin.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, admin.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, admin.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, admin.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, admin.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, admin.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, admin.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, admin.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, admin.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, admin.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, admin.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, admin.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, admin.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, admin.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, admin.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, admin.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, admin.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, admin.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, admin.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, admin.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, admin.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, admin.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, admin.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, admin.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, admin.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, admin.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, admin.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, admin.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	if i.HasRoles != nil {
		p := admin.HasRoles()
		if !*i.HasRoles {
			p = admin.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, admin.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAdminWhereInput
	case 1:
		return predicates[0], nil
	default:
		return admin.And(predicates...), nil
	}
}

// PermissionWhereInput represents a where input for filtering Permission queries.
type PermissionWhereInput struct {
	Predicates []predicate.Permission  `json:"-"`
	Not        *PermissionWhereInput   `json:"not,omitempty"`
	Or         []*PermissionWhereInput `json:"or,omitempty"`
	And        []*PermissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "group" field predicates.
	Group             *string  `json:"group,omitempty"`
	GroupNEQ          *string  `json:"groupNEQ,omitempty"`
	GroupIn           []string `json:"groupIn,omitempty"`
	GroupNotIn        []string `json:"groupNotIn,omitempty"`
	GroupGT           *string  `json:"groupGT,omitempty"`
	GroupGTE          *string  `json:"groupGTE,omitempty"`
	GroupLT           *string  `json:"groupLT,omitempty"`
	GroupLTE          *string  `json:"groupLTE,omitempty"`
	GroupContains     *string  `json:"groupContains,omitempty"`
	GroupHasPrefix    *string  `json:"groupHasPrefix,omitempty"`
	GroupHasSuffix    *string  `json:"groupHasSuffix,omitempty"`
	GroupEqualFold    *string  `json:"groupEqualFold,omitempty"`
	GroupContainsFold *string  `json:"groupContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PermissionWhereInput) AddPredicates(predicates ...predicate.Permission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PermissionWhereInput filter on the PermissionQuery builder.
func (i *PermissionWhereInput) Filter(q *PermissionQuery) (*PermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPermissionWhereInput is returned in case the PermissionWhereInput is empty.
var ErrEmptyPermissionWhereInput = errors.New("ent: empty predicate PermissionWhereInput")

// P returns a predicate for filtering permissions.
// An error is returned if the input is empty or invalid.
func (i *PermissionWhereInput) P() (predicate.Permission, error) {
	var predicates []predicate.Permission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, permission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Permission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, permission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Permission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, permission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, permission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, permission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, permission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, permission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, permission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, permission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, permission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, permission.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, permission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, permission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, permission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, permission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, permission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, permission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, permission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, permission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, permission.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, permission.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, permission.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, permission.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, permission.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, permission.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Group != nil {
		predicates = append(predicates, permission.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, permission.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, permission.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, permission.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, permission.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, permission.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, permission.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, permission.GroupLTE(*i.GroupLTE))
	}
	if i.GroupContains != nil {
		predicates = append(predicates, permission.GroupContains(*i.GroupContains))
	}
	if i.GroupHasPrefix != nil {
		predicates = append(predicates, permission.GroupHasPrefix(*i.GroupHasPrefix))
	}
	if i.GroupHasSuffix != nil {
		predicates = append(predicates, permission.GroupHasSuffix(*i.GroupHasSuffix))
	}
	if i.GroupEqualFold != nil {
		predicates = append(predicates, permission.GroupEqualFold(*i.GroupEqualFold))
	}
	if i.GroupContainsFold != nil {
		predicates = append(predicates, permission.GroupContainsFold(*i.GroupContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, permission.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, permission.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, permission.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, permission.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, permission.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, permission.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, permission.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, permission.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, permission.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, permission.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, permission.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, permission.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, permission.NameContainsFold(*i.NameContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, permission.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, permission.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, permission.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, permission.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, permission.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, permission.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, permission.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, permission.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, permission.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, permission.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, permission.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, permission.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, permission.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, permission.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, permission.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, permission.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, permission.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, permission.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, permission.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, permission.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, permission.OrderLTE(*i.OrderLTE))
	}

	if i.HasRoles != nil {
		p := permission.HasRoles()
		if !*i.HasRoles {
			p = permission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, permission.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return permission.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "is_changeable" field predicates.
	IsChangeable    *bool `json:"isChangeable,omitempty"`
	IsChangeableNEQ *bool `json:"isChangeableNEQ,omitempty"`

	// "admins" edge predicates.
	HasAdmins     *bool              `json:"hasAdmins,omitempty"`
	HasAdminsWith []*AdminWhereInput `json:"hasAdminsWith,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`

	// "routes" edge predicates.
	HasRoutes     *bool              `json:"hasRoutes,omitempty"`
	HasRoutesWith []*RouteWhereInput `json:"hasRoutesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, role.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, role.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, role.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, role.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, role.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, role.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, role.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, role.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, role.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, role.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, role.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, role.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, role.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, role.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, role.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, role.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, role.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, role.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, role.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, role.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, role.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, role.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, role.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, role.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, role.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, role.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, role.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, role.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, role.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, role.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, role.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, role.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, role.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, role.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, role.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, role.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, role.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, role.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, role.OrderLTE(*i.OrderLTE))
	}
	if i.IsChangeable != nil {
		predicates = append(predicates, role.IsChangeableEQ(*i.IsChangeable))
	}
	if i.IsChangeableNEQ != nil {
		predicates = append(predicates, role.IsChangeableNEQ(*i.IsChangeableNEQ))
	}

	if i.HasAdmins != nil {
		p := role.HasAdmins()
		if !*i.HasAdmins {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAdminsWith) > 0 {
		with := make([]predicate.Admin, 0, len(i.HasAdminsWith))
		for _, w := range i.HasAdminsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAdminsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasAdminsWith(with...))
	}
	if i.HasPermissions != nil {
		p := role.HasPermissions()
		if !*i.HasPermissions {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasPermissionsWith(with...))
	}
	if i.HasRoutes != nil {
		p := role.HasRoutes()
		if !*i.HasRoutes {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutesWith) > 0 {
		with := make([]predicate.Route, 0, len(i.HasRoutesWith))
		for _, w := range i.HasRoutesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasRoutesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}

// RouteWhereInput represents a where input for filtering Route queries.
type RouteWhereInput struct {
	Predicates []predicate.Route  `json:"-"`
	Not        *RouteWhereInput   `json:"not,omitempty"`
	Or         []*RouteWhereInput `json:"or,omitempty"`
	And        []*RouteWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "parent_id" field predicates.
	ParentID             *xid.ID  `json:"parentID,omitempty"`
	ParentIDNEQ          *xid.ID  `json:"parentIDNEQ,omitempty"`
	ParentIDIn           []xid.ID `json:"parentIDIn,omitempty"`
	ParentIDNotIn        []xid.ID `json:"parentIDNotIn,omitempty"`
	ParentIDGT           *xid.ID  `json:"parentIDGT,omitempty"`
	ParentIDGTE          *xid.ID  `json:"parentIDGTE,omitempty"`
	ParentIDLT           *xid.ID  `json:"parentIDLT,omitempty"`
	ParentIDLTE          *xid.ID  `json:"parentIDLTE,omitempty"`
	ParentIDContains     *xid.ID  `json:"parentIDContains,omitempty"`
	ParentIDHasPrefix    *xid.ID  `json:"parentIDHasPrefix,omitempty"`
	ParentIDHasSuffix    *xid.ID  `json:"parentIDHasSuffix,omitempty"`
	ParentIDIsNil        bool     `json:"parentIDIsNil,omitempty"`
	ParentIDNotNil       bool     `json:"parentIDNotNil,omitempty"`
	ParentIDEqualFold    *xid.ID  `json:"parentIDEqualFold,omitempty"`
	ParentIDContainsFold *xid.ID  `json:"parentIDContainsFold,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "component" field predicates.
	Component             *string  `json:"component,omitempty"`
	ComponentNEQ          *string  `json:"componentNEQ,omitempty"`
	ComponentIn           []string `json:"componentIn,omitempty"`
	ComponentNotIn        []string `json:"componentNotIn,omitempty"`
	ComponentGT           *string  `json:"componentGT,omitempty"`
	ComponentGTE          *string  `json:"componentGTE,omitempty"`
	ComponentLT           *string  `json:"componentLT,omitempty"`
	ComponentLTE          *string  `json:"componentLTE,omitempty"`
	ComponentContains     *string  `json:"componentContains,omitempty"`
	ComponentHasPrefix    *string  `json:"componentHasPrefix,omitempty"`
	ComponentHasSuffix    *string  `json:"componentHasSuffix,omitempty"`
	ComponentEqualFold    *string  `json:"componentEqualFold,omitempty"`
	ComponentContainsFold *string  `json:"componentContainsFold,omitempty"`

	// "redirect" field predicates.
	Redirect             *string  `json:"redirect,omitempty"`
	RedirectNEQ          *string  `json:"redirectNEQ,omitempty"`
	RedirectIn           []string `json:"redirectIn,omitempty"`
	RedirectNotIn        []string `json:"redirectNotIn,omitempty"`
	RedirectGT           *string  `json:"redirectGT,omitempty"`
	RedirectGTE          *string  `json:"redirectGTE,omitempty"`
	RedirectLT           *string  `json:"redirectLT,omitempty"`
	RedirectLTE          *string  `json:"redirectLTE,omitempty"`
	RedirectContains     *string  `json:"redirectContains,omitempty"`
	RedirectHasPrefix    *string  `json:"redirectHasPrefix,omitempty"`
	RedirectHasSuffix    *string  `json:"redirectHasSuffix,omitempty"`
	RedirectIsNil        bool     `json:"redirectIsNil,omitempty"`
	RedirectNotNil       bool     `json:"redirectNotNil,omitempty"`
	RedirectEqualFold    *string  `json:"redirectEqualFold,omitempty"`
	RedirectContainsFold *string  `json:"redirectContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "order" field predicates.
	Order       *int  `json:"order,omitempty"`
	OrderNEQ    *int  `json:"orderNEQ,omitempty"`
	OrderIn     []int `json:"orderIn,omitempty"`
	OrderNotIn  []int `json:"orderNotIn,omitempty"`
	OrderGT     *int  `json:"orderGT,omitempty"`
	OrderGTE    *int  `json:"orderGTE,omitempty"`
	OrderLT     *int  `json:"orderLT,omitempty"`
	OrderLTE    *int  `json:"orderLTE,omitempty"`
	OrderIsNil  bool  `json:"orderIsNil,omitempty"`
	OrderNotNil bool  `json:"orderNotNil,omitempty"`

	// "type" field predicates.
	Type      *route.Type  `json:"type,omitempty"`
	TypeNEQ   *route.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []route.Type `json:"typeIn,omitempty"`
	TypeNotIn []route.Type `json:"typeNotIn,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool              `json:"hasParent,omitempty"`
	HasParentWith []*RouteWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool              `json:"hasChildren,omitempty"`
	HasChildrenWith []*RouteWhereInput `json:"hasChildrenWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RouteWhereInput) AddPredicates(predicates ...predicate.Route) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RouteWhereInput filter on the RouteQuery builder.
func (i *RouteWhereInput) Filter(q *RouteQuery) (*RouteQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRouteWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRouteWhereInput is returned in case the RouteWhereInput is empty.
var ErrEmptyRouteWhereInput = errors.New("ent: empty predicate RouteWhereInput")

// P returns a predicate for filtering routes.
// An error is returned if the input is empty or invalid.
func (i *RouteWhereInput) P() (predicate.Route, error) {
	var predicates []predicate.Route
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, route.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Route, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, route.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Route, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, route.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, route.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, route.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, route.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, route.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, route.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, route.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, route.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, route.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, route.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, route.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, route.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, route.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, route.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, route.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, route.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, route.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, route.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, route.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, route.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, route.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, route.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, route.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, route.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, route.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, route.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, route.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, route.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, route.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, route.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, route.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, route.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, route.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, route.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, route.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.ParentID != nil {
		predicates = append(predicates, route.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, route.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, route.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, route.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.ParentIDGT != nil {
		predicates = append(predicates, route.ParentIDGT(*i.ParentIDGT))
	}
	if i.ParentIDGTE != nil {
		predicates = append(predicates, route.ParentIDGTE(*i.ParentIDGTE))
	}
	if i.ParentIDLT != nil {
		predicates = append(predicates, route.ParentIDLT(*i.ParentIDLT))
	}
	if i.ParentIDLTE != nil {
		predicates = append(predicates, route.ParentIDLTE(*i.ParentIDLTE))
	}
	if i.ParentIDContains != nil {
		predicates = append(predicates, route.ParentIDContains(*i.ParentIDContains))
	}
	if i.ParentIDHasPrefix != nil {
		predicates = append(predicates, route.ParentIDHasPrefix(*i.ParentIDHasPrefix))
	}
	if i.ParentIDHasSuffix != nil {
		predicates = append(predicates, route.ParentIDHasSuffix(*i.ParentIDHasSuffix))
	}
	if i.ParentIDIsNil {
		predicates = append(predicates, route.ParentIDIsNil())
	}
	if i.ParentIDNotNil {
		predicates = append(predicates, route.ParentIDNotNil())
	}
	if i.ParentIDEqualFold != nil {
		predicates = append(predicates, route.ParentIDEqualFold(*i.ParentIDEqualFold))
	}
	if i.ParentIDContainsFold != nil {
		predicates = append(predicates, route.ParentIDContainsFold(*i.ParentIDContainsFold))
	}
	if i.Path != nil {
		predicates = append(predicates, route.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, route.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, route.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, route.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, route.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, route.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, route.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, route.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, route.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, route.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, route.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, route.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, route.PathContainsFold(*i.PathContainsFold))
	}
	if i.Component != nil {
		predicates = append(predicates, route.ComponentEQ(*i.Component))
	}
	if i.ComponentNEQ != nil {
		predicates = append(predicates, route.ComponentNEQ(*i.ComponentNEQ))
	}
	if len(i.ComponentIn) > 0 {
		predicates = append(predicates, route.ComponentIn(i.ComponentIn...))
	}
	if len(i.ComponentNotIn) > 0 {
		predicates = append(predicates, route.ComponentNotIn(i.ComponentNotIn...))
	}
	if i.ComponentGT != nil {
		predicates = append(predicates, route.ComponentGT(*i.ComponentGT))
	}
	if i.ComponentGTE != nil {
		predicates = append(predicates, route.ComponentGTE(*i.ComponentGTE))
	}
	if i.ComponentLT != nil {
		predicates = append(predicates, route.ComponentLT(*i.ComponentLT))
	}
	if i.ComponentLTE != nil {
		predicates = append(predicates, route.ComponentLTE(*i.ComponentLTE))
	}
	if i.ComponentContains != nil {
		predicates = append(predicates, route.ComponentContains(*i.ComponentContains))
	}
	if i.ComponentHasPrefix != nil {
		predicates = append(predicates, route.ComponentHasPrefix(*i.ComponentHasPrefix))
	}
	if i.ComponentHasSuffix != nil {
		predicates = append(predicates, route.ComponentHasSuffix(*i.ComponentHasSuffix))
	}
	if i.ComponentEqualFold != nil {
		predicates = append(predicates, route.ComponentEqualFold(*i.ComponentEqualFold))
	}
	if i.ComponentContainsFold != nil {
		predicates = append(predicates, route.ComponentContainsFold(*i.ComponentContainsFold))
	}
	if i.Redirect != nil {
		predicates = append(predicates, route.RedirectEQ(*i.Redirect))
	}
	if i.RedirectNEQ != nil {
		predicates = append(predicates, route.RedirectNEQ(*i.RedirectNEQ))
	}
	if len(i.RedirectIn) > 0 {
		predicates = append(predicates, route.RedirectIn(i.RedirectIn...))
	}
	if len(i.RedirectNotIn) > 0 {
		predicates = append(predicates, route.RedirectNotIn(i.RedirectNotIn...))
	}
	if i.RedirectGT != nil {
		predicates = append(predicates, route.RedirectGT(*i.RedirectGT))
	}
	if i.RedirectGTE != nil {
		predicates = append(predicates, route.RedirectGTE(*i.RedirectGTE))
	}
	if i.RedirectLT != nil {
		predicates = append(predicates, route.RedirectLT(*i.RedirectLT))
	}
	if i.RedirectLTE != nil {
		predicates = append(predicates, route.RedirectLTE(*i.RedirectLTE))
	}
	if i.RedirectContains != nil {
		predicates = append(predicates, route.RedirectContains(*i.RedirectContains))
	}
	if i.RedirectHasPrefix != nil {
		predicates = append(predicates, route.RedirectHasPrefix(*i.RedirectHasPrefix))
	}
	if i.RedirectHasSuffix != nil {
		predicates = append(predicates, route.RedirectHasSuffix(*i.RedirectHasSuffix))
	}
	if i.RedirectIsNil {
		predicates = append(predicates, route.RedirectIsNil())
	}
	if i.RedirectNotNil {
		predicates = append(predicates, route.RedirectNotNil())
	}
	if i.RedirectEqualFold != nil {
		predicates = append(predicates, route.RedirectEqualFold(*i.RedirectEqualFold))
	}
	if i.RedirectContainsFold != nil {
		predicates = append(predicates, route.RedirectContainsFold(*i.RedirectContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, route.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, route.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, route.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, route.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, route.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, route.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, route.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, route.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, route.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, route.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, route.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, route.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, route.NameContainsFold(*i.NameContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, route.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, route.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, route.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, route.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, route.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, route.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, route.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, route.OrderLTE(*i.OrderLTE))
	}
	if i.OrderIsNil {
		predicates = append(predicates, route.OrderIsNil())
	}
	if i.OrderNotNil {
		predicates = append(predicates, route.OrderNotNil())
	}
	if i.Type != nil {
		predicates = append(predicates, route.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, route.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, route.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, route.TypeNotIn(i.TypeNotIn...))
	}

	if i.HasParent != nil {
		p := route.HasParent()
		if !*i.HasParent {
			p = route.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Route, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, route.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := route.HasChildren()
		if !*i.HasChildren {
			p = route.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Route, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, route.HasChildrenWith(with...))
	}
	if i.HasRoles != nil {
		p := route.HasRoles()
		if !*i.HasRoles {
			p = route.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, route.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRouteWhereInput
	case 1:
		return predicates[0], nil
	default:
		return route.And(predicates...), nil
	}
}
