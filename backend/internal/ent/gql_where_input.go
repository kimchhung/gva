// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/gva/app/database/schema/xid"
	"github.com/gva/internal/ent/admin"
	"github.com/gva/internal/ent/department"
	"github.com/gva/internal/ent/menu"
	"github.com/gva/internal/ent/permission"
	"github.com/gva/internal/ent/predicate"
	"github.com/gva/internal/ent/region"
	"github.com/gva/internal/ent/role"
)

// AdminWhereInput represents a where input for filtering Admin queries.
type AdminWhereInput struct {
	Predicates []predicate.Admin  `json:"-"`
	Not        *AdminWhereInput   `json:"not,omitempty"`
	Or         []*AdminWhereInput `json:"or,omitempty"`
	And        []*AdminWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "department_id" field predicates.
	DepartmentID             *xid.ID  `json:"departmentID,omitempty"`
	DepartmentIDNEQ          *xid.ID  `json:"departmentIDNEQ,omitempty"`
	DepartmentIDIn           []xid.ID `json:"departmentIDIn,omitempty"`
	DepartmentIDNotIn        []xid.ID `json:"departmentIDNotIn,omitempty"`
	DepartmentIDGT           *xid.ID  `json:"departmentIDGT,omitempty"`
	DepartmentIDGTE          *xid.ID  `json:"departmentIDGTE,omitempty"`
	DepartmentIDLT           *xid.ID  `json:"departmentIDLT,omitempty"`
	DepartmentIDLTE          *xid.ID  `json:"departmentIDLTE,omitempty"`
	DepartmentIDContains     *xid.ID  `json:"departmentIDContains,omitempty"`
	DepartmentIDHasPrefix    *xid.ID  `json:"departmentIDHasPrefix,omitempty"`
	DepartmentIDHasSuffix    *xid.ID  `json:"departmentIDHasSuffix,omitempty"`
	DepartmentIDIsNil        bool     `json:"departmentIDIsNil,omitempty"`
	DepartmentIDNotNil       bool     `json:"departmentIDNotNil,omitempty"`
	DepartmentIDEqualFold    *xid.ID  `json:"departmentIDEqualFold,omitempty"`
	DepartmentIDContainsFold *xid.ID  `json:"departmentIDContainsFold,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`

	// "department" edge predicates.
	HasDepartment     *bool                   `json:"hasDepartment,omitempty"`
	HasDepartmentWith []*DepartmentWhereInput `json:"hasDepartmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AdminWhereInput) AddPredicates(predicates ...predicate.Admin) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AdminWhereInput filter on the AdminQuery builder.
func (i *AdminWhereInput) Filter(q *AdminQuery) (*AdminQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAdminWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAdminWhereInput is returned in case the AdminWhereInput is empty.
var ErrEmptyAdminWhereInput = errors.New("ent: empty predicate AdminWhereInput")

// P returns a predicate for filtering admins.
// An error is returned if the input is empty or invalid.
func (i *AdminWhereInput) P() (predicate.Admin, error) {
	var predicates []predicate.Admin
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, admin.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Admin, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, admin.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Admin, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, admin.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, admin.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, admin.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, admin.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, admin.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, admin.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, admin.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, admin.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, admin.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, admin.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, admin.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, admin.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, admin.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, admin.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, admin.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, admin.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, admin.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, admin.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, admin.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, admin.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, admin.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, admin.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, admin.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, admin.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, admin.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, admin.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, admin.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, admin.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, admin.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, admin.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, admin.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, admin.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, admin.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, admin.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, admin.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, admin.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, admin.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, admin.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, admin.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, admin.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, admin.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, admin.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, admin.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, admin.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, admin.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, admin.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, admin.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, admin.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, admin.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, admin.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, admin.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, admin.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, admin.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, admin.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, admin.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, admin.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, admin.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, admin.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, admin.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, admin.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, admin.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, admin.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, admin.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, admin.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, admin.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, admin.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, admin.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, admin.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, admin.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, admin.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, admin.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, admin.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, admin.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, admin.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, admin.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, admin.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.DepartmentID != nil {
		predicates = append(predicates, admin.DepartmentIDEQ(*i.DepartmentID))
	}
	if i.DepartmentIDNEQ != nil {
		predicates = append(predicates, admin.DepartmentIDNEQ(*i.DepartmentIDNEQ))
	}
	if len(i.DepartmentIDIn) > 0 {
		predicates = append(predicates, admin.DepartmentIDIn(i.DepartmentIDIn...))
	}
	if len(i.DepartmentIDNotIn) > 0 {
		predicates = append(predicates, admin.DepartmentIDNotIn(i.DepartmentIDNotIn...))
	}
	if i.DepartmentIDGT != nil {
		predicates = append(predicates, admin.DepartmentIDGT(*i.DepartmentIDGT))
	}
	if i.DepartmentIDGTE != nil {
		predicates = append(predicates, admin.DepartmentIDGTE(*i.DepartmentIDGTE))
	}
	if i.DepartmentIDLT != nil {
		predicates = append(predicates, admin.DepartmentIDLT(*i.DepartmentIDLT))
	}
	if i.DepartmentIDLTE != nil {
		predicates = append(predicates, admin.DepartmentIDLTE(*i.DepartmentIDLTE))
	}
	if i.DepartmentIDContains != nil {
		predicates = append(predicates, admin.DepartmentIDContains(*i.DepartmentIDContains))
	}
	if i.DepartmentIDHasPrefix != nil {
		predicates = append(predicates, admin.DepartmentIDHasPrefix(*i.DepartmentIDHasPrefix))
	}
	if i.DepartmentIDHasSuffix != nil {
		predicates = append(predicates, admin.DepartmentIDHasSuffix(*i.DepartmentIDHasSuffix))
	}
	if i.DepartmentIDIsNil {
		predicates = append(predicates, admin.DepartmentIDIsNil())
	}
	if i.DepartmentIDNotNil {
		predicates = append(predicates, admin.DepartmentIDNotNil())
	}
	if i.DepartmentIDEqualFold != nil {
		predicates = append(predicates, admin.DepartmentIDEqualFold(*i.DepartmentIDEqualFold))
	}
	if i.DepartmentIDContainsFold != nil {
		predicates = append(predicates, admin.DepartmentIDContainsFold(*i.DepartmentIDContainsFold))
	}

	if i.HasRoles != nil {
		p := admin.HasRoles()
		if !*i.HasRoles {
			p = admin.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, admin.HasRolesWith(with...))
	}
	if i.HasDepartment != nil {
		p := admin.HasDepartment()
		if !*i.HasDepartment {
			p = admin.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDepartmentWith) > 0 {
		with := make([]predicate.Department, 0, len(i.HasDepartmentWith))
		for _, w := range i.HasDepartmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDepartmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, admin.HasDepartmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAdminWhereInput
	case 1:
		return predicates[0], nil
	default:
		return admin.And(predicates...), nil
	}
}

// DepartmentWhereInput represents a where input for filtering Department queries.
type DepartmentWhereInput struct {
	Predicates []predicate.Department  `json:"-"`
	Not        *DepartmentWhereInput   `json:"not,omitempty"`
	Or         []*DepartmentWhereInput `json:"or,omitempty"`
	And        []*DepartmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "name_id" field predicates.
	NameID             *string  `json:"nameID,omitempty"`
	NameIDNEQ          *string  `json:"nameIDNEQ,omitempty"`
	NameIDIn           []string `json:"nameIDIn,omitempty"`
	NameIDNotIn        []string `json:"nameIDNotIn,omitempty"`
	NameIDGT           *string  `json:"nameIDGT,omitempty"`
	NameIDGTE          *string  `json:"nameIDGTE,omitempty"`
	NameIDLT           *string  `json:"nameIDLT,omitempty"`
	NameIDLTE          *string  `json:"nameIDLTE,omitempty"`
	NameIDContains     *string  `json:"nameIDContains,omitempty"`
	NameIDHasPrefix    *string  `json:"nameIDHasPrefix,omitempty"`
	NameIDHasSuffix    *string  `json:"nameIDHasSuffix,omitempty"`
	NameIDEqualFold    *string  `json:"nameIDEqualFold,omitempty"`
	NameIDContainsFold *string  `json:"nameIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "parent_id" field predicates.
	ParentID             *xid.ID  `json:"parentID,omitempty"`
	ParentIDNEQ          *xid.ID  `json:"parentIDNEQ,omitempty"`
	ParentIDIn           []xid.ID `json:"parentIDIn,omitempty"`
	ParentIDNotIn        []xid.ID `json:"parentIDNotIn,omitempty"`
	ParentIDGT           *xid.ID  `json:"parentIDGT,omitempty"`
	ParentIDGTE          *xid.ID  `json:"parentIDGTE,omitempty"`
	ParentIDLT           *xid.ID  `json:"parentIDLT,omitempty"`
	ParentIDLTE          *xid.ID  `json:"parentIDLTE,omitempty"`
	ParentIDContains     *xid.ID  `json:"parentIDContains,omitempty"`
	ParentIDHasPrefix    *xid.ID  `json:"parentIDHasPrefix,omitempty"`
	ParentIDHasSuffix    *xid.ID  `json:"parentIDHasSuffix,omitempty"`
	ParentIDIsNil        bool     `json:"parentIDIsNil,omitempty"`
	ParentIDNotNil       bool     `json:"parentIDNotNil,omitempty"`
	ParentIDEqualFold    *xid.ID  `json:"parentIDEqualFold,omitempty"`
	ParentIDContainsFold *xid.ID  `json:"parentIDContainsFold,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool                   `json:"hasParent,omitempty"`
	HasParentWith []*DepartmentWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool                   `json:"hasChildren,omitempty"`
	HasChildrenWith []*DepartmentWhereInput `json:"hasChildrenWith,omitempty"`

	// "members" edge predicates.
	HasMembers     *bool              `json:"hasMembers,omitempty"`
	HasMembersWith []*AdminWhereInput `json:"hasMembersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DepartmentWhereInput) AddPredicates(predicates ...predicate.Department) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DepartmentWhereInput filter on the DepartmentQuery builder.
func (i *DepartmentWhereInput) Filter(q *DepartmentQuery) (*DepartmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDepartmentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDepartmentWhereInput is returned in case the DepartmentWhereInput is empty.
var ErrEmptyDepartmentWhereInput = errors.New("ent: empty predicate DepartmentWhereInput")

// P returns a predicate for filtering departments.
// An error is returned if the input is empty or invalid.
func (i *DepartmentWhereInput) P() (predicate.Department, error) {
	var predicates []predicate.Department
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, department.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Department, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, department.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Department, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, department.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, department.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, department.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, department.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, department.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, department.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, department.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, department.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, department.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, department.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, department.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, department.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, department.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, department.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, department.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, department.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, department.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, department.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, department.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, department.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, department.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, department.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, department.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, department.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, department.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, department.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, department.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, department.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, department.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, department.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, department.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, department.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, department.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, department.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, department.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.NameID != nil {
		predicates = append(predicates, department.NameIDEQ(*i.NameID))
	}
	if i.NameIDNEQ != nil {
		predicates = append(predicates, department.NameIDNEQ(*i.NameIDNEQ))
	}
	if len(i.NameIDIn) > 0 {
		predicates = append(predicates, department.NameIDIn(i.NameIDIn...))
	}
	if len(i.NameIDNotIn) > 0 {
		predicates = append(predicates, department.NameIDNotIn(i.NameIDNotIn...))
	}
	if i.NameIDGT != nil {
		predicates = append(predicates, department.NameIDGT(*i.NameIDGT))
	}
	if i.NameIDGTE != nil {
		predicates = append(predicates, department.NameIDGTE(*i.NameIDGTE))
	}
	if i.NameIDLT != nil {
		predicates = append(predicates, department.NameIDLT(*i.NameIDLT))
	}
	if i.NameIDLTE != nil {
		predicates = append(predicates, department.NameIDLTE(*i.NameIDLTE))
	}
	if i.NameIDContains != nil {
		predicates = append(predicates, department.NameIDContains(*i.NameIDContains))
	}
	if i.NameIDHasPrefix != nil {
		predicates = append(predicates, department.NameIDHasPrefix(*i.NameIDHasPrefix))
	}
	if i.NameIDHasSuffix != nil {
		predicates = append(predicates, department.NameIDHasSuffix(*i.NameIDHasSuffix))
	}
	if i.NameIDEqualFold != nil {
		predicates = append(predicates, department.NameIDEqualFold(*i.NameIDEqualFold))
	}
	if i.NameIDContainsFold != nil {
		predicates = append(predicates, department.NameIDContainsFold(*i.NameIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, department.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, department.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, department.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, department.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, department.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, department.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, department.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, department.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, department.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, department.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, department.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, department.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, department.NameContainsFold(*i.NameContainsFold))
	}
	if i.ParentID != nil {
		predicates = append(predicates, department.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, department.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, department.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, department.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.ParentIDGT != nil {
		predicates = append(predicates, department.ParentIDGT(*i.ParentIDGT))
	}
	if i.ParentIDGTE != nil {
		predicates = append(predicates, department.ParentIDGTE(*i.ParentIDGTE))
	}
	if i.ParentIDLT != nil {
		predicates = append(predicates, department.ParentIDLT(*i.ParentIDLT))
	}
	if i.ParentIDLTE != nil {
		predicates = append(predicates, department.ParentIDLTE(*i.ParentIDLTE))
	}
	if i.ParentIDContains != nil {
		predicates = append(predicates, department.ParentIDContains(*i.ParentIDContains))
	}
	if i.ParentIDHasPrefix != nil {
		predicates = append(predicates, department.ParentIDHasPrefix(*i.ParentIDHasPrefix))
	}
	if i.ParentIDHasSuffix != nil {
		predicates = append(predicates, department.ParentIDHasSuffix(*i.ParentIDHasSuffix))
	}
	if i.ParentIDIsNil {
		predicates = append(predicates, department.ParentIDIsNil())
	}
	if i.ParentIDNotNil {
		predicates = append(predicates, department.ParentIDNotNil())
	}
	if i.ParentIDEqualFold != nil {
		predicates = append(predicates, department.ParentIDEqualFold(*i.ParentIDEqualFold))
	}
	if i.ParentIDContainsFold != nil {
		predicates = append(predicates, department.ParentIDContainsFold(*i.ParentIDContainsFold))
	}

	if i.HasParent != nil {
		p := department.HasParent()
		if !*i.HasParent {
			p = department.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Department, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, department.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := department.HasChildren()
		if !*i.HasChildren {
			p = department.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Department, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, department.HasChildrenWith(with...))
	}
	if i.HasMembers != nil {
		p := department.HasMembers()
		if !*i.HasMembers {
			p = department.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMembersWith) > 0 {
		with := make([]predicate.Admin, 0, len(i.HasMembersWith))
		for _, w := range i.HasMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMembersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, department.HasMembersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDepartmentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return department.And(predicates...), nil
	}
}

// MenuWhereInput represents a where input for filtering Menu queries.
type MenuWhereInput struct {
	Predicates []predicate.Menu  `json:"-"`
	Not        *MenuWhereInput   `json:"not,omitempty"`
	Or         []*MenuWhereInput `json:"or,omitempty"`
	And        []*MenuWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "parent_id" field predicates.
	ParentID             *xid.ID  `json:"parentID,omitempty"`
	ParentIDNEQ          *xid.ID  `json:"parentIDNEQ,omitempty"`
	ParentIDIn           []xid.ID `json:"parentIDIn,omitempty"`
	ParentIDNotIn        []xid.ID `json:"parentIDNotIn,omitempty"`
	ParentIDGT           *xid.ID  `json:"parentIDGT,omitempty"`
	ParentIDGTE          *xid.ID  `json:"parentIDGTE,omitempty"`
	ParentIDLT           *xid.ID  `json:"parentIDLT,omitempty"`
	ParentIDLTE          *xid.ID  `json:"parentIDLTE,omitempty"`
	ParentIDContains     *xid.ID  `json:"parentIDContains,omitempty"`
	ParentIDHasPrefix    *xid.ID  `json:"parentIDHasPrefix,omitempty"`
	ParentIDHasSuffix    *xid.ID  `json:"parentIDHasSuffix,omitempty"`
	ParentIDIsNil        bool     `json:"parentIDIsNil,omitempty"`
	ParentIDNotNil       bool     `json:"parentIDNotNil,omitempty"`
	ParentIDEqualFold    *xid.ID  `json:"parentIDEqualFold,omitempty"`
	ParentIDContainsFold *xid.ID  `json:"parentIDContainsFold,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "component" field predicates.
	Component             *string  `json:"component,omitempty"`
	ComponentNEQ          *string  `json:"componentNEQ,omitempty"`
	ComponentIn           []string `json:"componentIn,omitempty"`
	ComponentNotIn        []string `json:"componentNotIn,omitempty"`
	ComponentGT           *string  `json:"componentGT,omitempty"`
	ComponentGTE          *string  `json:"componentGTE,omitempty"`
	ComponentLT           *string  `json:"componentLT,omitempty"`
	ComponentLTE          *string  `json:"componentLTE,omitempty"`
	ComponentContains     *string  `json:"componentContains,omitempty"`
	ComponentHasPrefix    *string  `json:"componentHasPrefix,omitempty"`
	ComponentHasSuffix    *string  `json:"componentHasSuffix,omitempty"`
	ComponentEqualFold    *string  `json:"componentEqualFold,omitempty"`
	ComponentContainsFold *string  `json:"componentContainsFold,omitempty"`

	// "redirect" field predicates.
	Redirect             *string  `json:"redirect,omitempty"`
	RedirectNEQ          *string  `json:"redirectNEQ,omitempty"`
	RedirectIn           []string `json:"redirectIn,omitempty"`
	RedirectNotIn        []string `json:"redirectNotIn,omitempty"`
	RedirectGT           *string  `json:"redirectGT,omitempty"`
	RedirectGTE          *string  `json:"redirectGTE,omitempty"`
	RedirectLT           *string  `json:"redirectLT,omitempty"`
	RedirectLTE          *string  `json:"redirectLTE,omitempty"`
	RedirectContains     *string  `json:"redirectContains,omitempty"`
	RedirectHasPrefix    *string  `json:"redirectHasPrefix,omitempty"`
	RedirectHasSuffix    *string  `json:"redirectHasSuffix,omitempty"`
	RedirectIsNil        bool     `json:"redirectIsNil,omitempty"`
	RedirectNotNil       bool     `json:"redirectNotNil,omitempty"`
	RedirectEqualFold    *string  `json:"redirectEqualFold,omitempty"`
	RedirectContainsFold *string  `json:"redirectContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "order" field predicates.
	Order       *int  `json:"order,omitempty"`
	OrderNEQ    *int  `json:"orderNEQ,omitempty"`
	OrderIn     []int `json:"orderIn,omitempty"`
	OrderNotIn  []int `json:"orderNotIn,omitempty"`
	OrderGT     *int  `json:"orderGT,omitempty"`
	OrderGTE    *int  `json:"orderGTE,omitempty"`
	OrderLT     *int  `json:"orderLT,omitempty"`
	OrderLTE    *int  `json:"orderLTE,omitempty"`
	OrderIsNil  bool  `json:"orderIsNil,omitempty"`
	OrderNotNil bool  `json:"orderNotNil,omitempty"`

	// "type" field predicates.
	Type      *menu.Type  `json:"type,omitempty"`
	TypeNEQ   *menu.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []menu.Type `json:"typeIn,omitempty"`
	TypeNotIn []menu.Type `json:"typeNotIn,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool             `json:"hasParent,omitempty"`
	HasParentWith []*MenuWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool             `json:"hasChildren,omitempty"`
	HasChildrenWith []*MenuWhereInput `json:"hasChildrenWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MenuWhereInput) AddPredicates(predicates ...predicate.Menu) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MenuWhereInput filter on the MenuQuery builder.
func (i *MenuWhereInput) Filter(q *MenuQuery) (*MenuQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMenuWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMenuWhereInput is returned in case the MenuWhereInput is empty.
var ErrEmptyMenuWhereInput = errors.New("ent: empty predicate MenuWhereInput")

// P returns a predicate for filtering menus.
// An error is returned if the input is empty or invalid.
func (i *MenuWhereInput) P() (predicate.Menu, error) {
	var predicates []predicate.Menu
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, menu.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Menu, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, menu.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Menu, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, menu.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, menu.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, menu.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, menu.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, menu.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, menu.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, menu.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, menu.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, menu.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, menu.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, menu.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, menu.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, menu.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, menu.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, menu.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, menu.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, menu.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, menu.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, menu.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, menu.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, menu.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, menu.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, menu.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, menu.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, menu.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, menu.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, menu.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, menu.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, menu.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, menu.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, menu.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, menu.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, menu.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, menu.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, menu.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.ParentID != nil {
		predicates = append(predicates, menu.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, menu.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, menu.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, menu.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.ParentIDGT != nil {
		predicates = append(predicates, menu.ParentIDGT(*i.ParentIDGT))
	}
	if i.ParentIDGTE != nil {
		predicates = append(predicates, menu.ParentIDGTE(*i.ParentIDGTE))
	}
	if i.ParentIDLT != nil {
		predicates = append(predicates, menu.ParentIDLT(*i.ParentIDLT))
	}
	if i.ParentIDLTE != nil {
		predicates = append(predicates, menu.ParentIDLTE(*i.ParentIDLTE))
	}
	if i.ParentIDContains != nil {
		predicates = append(predicates, menu.ParentIDContains(*i.ParentIDContains))
	}
	if i.ParentIDHasPrefix != nil {
		predicates = append(predicates, menu.ParentIDHasPrefix(*i.ParentIDHasPrefix))
	}
	if i.ParentIDHasSuffix != nil {
		predicates = append(predicates, menu.ParentIDHasSuffix(*i.ParentIDHasSuffix))
	}
	if i.ParentIDIsNil {
		predicates = append(predicates, menu.ParentIDIsNil())
	}
	if i.ParentIDNotNil {
		predicates = append(predicates, menu.ParentIDNotNil())
	}
	if i.ParentIDEqualFold != nil {
		predicates = append(predicates, menu.ParentIDEqualFold(*i.ParentIDEqualFold))
	}
	if i.ParentIDContainsFold != nil {
		predicates = append(predicates, menu.ParentIDContainsFold(*i.ParentIDContainsFold))
	}
	if i.Path != nil {
		predicates = append(predicates, menu.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, menu.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, menu.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, menu.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, menu.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, menu.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, menu.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, menu.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, menu.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, menu.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, menu.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, menu.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, menu.PathContainsFold(*i.PathContainsFold))
	}
	if i.Component != nil {
		predicates = append(predicates, menu.ComponentEQ(*i.Component))
	}
	if i.ComponentNEQ != nil {
		predicates = append(predicates, menu.ComponentNEQ(*i.ComponentNEQ))
	}
	if len(i.ComponentIn) > 0 {
		predicates = append(predicates, menu.ComponentIn(i.ComponentIn...))
	}
	if len(i.ComponentNotIn) > 0 {
		predicates = append(predicates, menu.ComponentNotIn(i.ComponentNotIn...))
	}
	if i.ComponentGT != nil {
		predicates = append(predicates, menu.ComponentGT(*i.ComponentGT))
	}
	if i.ComponentGTE != nil {
		predicates = append(predicates, menu.ComponentGTE(*i.ComponentGTE))
	}
	if i.ComponentLT != nil {
		predicates = append(predicates, menu.ComponentLT(*i.ComponentLT))
	}
	if i.ComponentLTE != nil {
		predicates = append(predicates, menu.ComponentLTE(*i.ComponentLTE))
	}
	if i.ComponentContains != nil {
		predicates = append(predicates, menu.ComponentContains(*i.ComponentContains))
	}
	if i.ComponentHasPrefix != nil {
		predicates = append(predicates, menu.ComponentHasPrefix(*i.ComponentHasPrefix))
	}
	if i.ComponentHasSuffix != nil {
		predicates = append(predicates, menu.ComponentHasSuffix(*i.ComponentHasSuffix))
	}
	if i.ComponentEqualFold != nil {
		predicates = append(predicates, menu.ComponentEqualFold(*i.ComponentEqualFold))
	}
	if i.ComponentContainsFold != nil {
		predicates = append(predicates, menu.ComponentContainsFold(*i.ComponentContainsFold))
	}
	if i.Redirect != nil {
		predicates = append(predicates, menu.RedirectEQ(*i.Redirect))
	}
	if i.RedirectNEQ != nil {
		predicates = append(predicates, menu.RedirectNEQ(*i.RedirectNEQ))
	}
	if len(i.RedirectIn) > 0 {
		predicates = append(predicates, menu.RedirectIn(i.RedirectIn...))
	}
	if len(i.RedirectNotIn) > 0 {
		predicates = append(predicates, menu.RedirectNotIn(i.RedirectNotIn...))
	}
	if i.RedirectGT != nil {
		predicates = append(predicates, menu.RedirectGT(*i.RedirectGT))
	}
	if i.RedirectGTE != nil {
		predicates = append(predicates, menu.RedirectGTE(*i.RedirectGTE))
	}
	if i.RedirectLT != nil {
		predicates = append(predicates, menu.RedirectLT(*i.RedirectLT))
	}
	if i.RedirectLTE != nil {
		predicates = append(predicates, menu.RedirectLTE(*i.RedirectLTE))
	}
	if i.RedirectContains != nil {
		predicates = append(predicates, menu.RedirectContains(*i.RedirectContains))
	}
	if i.RedirectHasPrefix != nil {
		predicates = append(predicates, menu.RedirectHasPrefix(*i.RedirectHasPrefix))
	}
	if i.RedirectHasSuffix != nil {
		predicates = append(predicates, menu.RedirectHasSuffix(*i.RedirectHasSuffix))
	}
	if i.RedirectIsNil {
		predicates = append(predicates, menu.RedirectIsNil())
	}
	if i.RedirectNotNil {
		predicates = append(predicates, menu.RedirectNotNil())
	}
	if i.RedirectEqualFold != nil {
		predicates = append(predicates, menu.RedirectEqualFold(*i.RedirectEqualFold))
	}
	if i.RedirectContainsFold != nil {
		predicates = append(predicates, menu.RedirectContainsFold(*i.RedirectContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, menu.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, menu.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, menu.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, menu.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, menu.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, menu.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, menu.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, menu.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, menu.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, menu.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, menu.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, menu.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, menu.NameContainsFold(*i.NameContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, menu.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, menu.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, menu.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, menu.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, menu.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, menu.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, menu.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, menu.OrderLTE(*i.OrderLTE))
	}
	if i.OrderIsNil {
		predicates = append(predicates, menu.OrderIsNil())
	}
	if i.OrderNotNil {
		predicates = append(predicates, menu.OrderNotNil())
	}
	if i.Type != nil {
		predicates = append(predicates, menu.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, menu.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, menu.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, menu.TypeNotIn(i.TypeNotIn...))
	}

	if i.HasParent != nil {
		p := menu.HasParent()
		if !*i.HasParent {
			p = menu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Menu, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, menu.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := menu.HasChildren()
		if !*i.HasChildren {
			p = menu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Menu, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, menu.HasChildrenWith(with...))
	}
	if i.HasRoles != nil {
		p := menu.HasRoles()
		if !*i.HasRoles {
			p = menu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, menu.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMenuWhereInput
	case 1:
		return predicates[0], nil
	default:
		return menu.And(predicates...), nil
	}
}

// PermissionWhereInput represents a where input for filtering Permission queries.
type PermissionWhereInput struct {
	Predicates []predicate.Permission  `json:"-"`
	Not        *PermissionWhereInput   `json:"not,omitempty"`
	Or         []*PermissionWhereInput `json:"or,omitempty"`
	And        []*PermissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "group" field predicates.
	Group             *string  `json:"group,omitempty"`
	GroupNEQ          *string  `json:"groupNEQ,omitempty"`
	GroupIn           []string `json:"groupIn,omitempty"`
	GroupNotIn        []string `json:"groupNotIn,omitempty"`
	GroupGT           *string  `json:"groupGT,omitempty"`
	GroupGTE          *string  `json:"groupGTE,omitempty"`
	GroupLT           *string  `json:"groupLT,omitempty"`
	GroupLTE          *string  `json:"groupLTE,omitempty"`
	GroupContains     *string  `json:"groupContains,omitempty"`
	GroupHasPrefix    *string  `json:"groupHasPrefix,omitempty"`
	GroupHasSuffix    *string  `json:"groupHasSuffix,omitempty"`
	GroupEqualFold    *string  `json:"groupEqualFold,omitempty"`
	GroupContainsFold *string  `json:"groupContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "type" field predicates.
	Type       *permission.Type  `json:"type,omitempty"`
	TypeNEQ    *permission.Type  `json:"typeNEQ,omitempty"`
	TypeIn     []permission.Type `json:"typeIn,omitempty"`
	TypeNotIn  []permission.Type `json:"typeNotIn,omitempty"`
	TypeIsNil  bool              `json:"typeIsNil,omitempty"`
	TypeNotNil bool              `json:"typeNotNil,omitempty"`

	// "order" field predicates.
	Order       *int  `json:"order,omitempty"`
	OrderNEQ    *int  `json:"orderNEQ,omitempty"`
	OrderIn     []int `json:"orderIn,omitempty"`
	OrderNotIn  []int `json:"orderNotIn,omitempty"`
	OrderGT     *int  `json:"orderGT,omitempty"`
	OrderGTE    *int  `json:"orderGTE,omitempty"`
	OrderLT     *int  `json:"orderLT,omitempty"`
	OrderLTE    *int  `json:"orderLTE,omitempty"`
	OrderIsNil  bool  `json:"orderIsNil,omitempty"`
	OrderNotNil bool  `json:"orderNotNil,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PermissionWhereInput) AddPredicates(predicates ...predicate.Permission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PermissionWhereInput filter on the PermissionQuery builder.
func (i *PermissionWhereInput) Filter(q *PermissionQuery) (*PermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPermissionWhereInput is returned in case the PermissionWhereInput is empty.
var ErrEmptyPermissionWhereInput = errors.New("ent: empty predicate PermissionWhereInput")

// P returns a predicate for filtering permissions.
// An error is returned if the input is empty or invalid.
func (i *PermissionWhereInput) P() (predicate.Permission, error) {
	var predicates []predicate.Permission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, permission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Permission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, permission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Permission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, permission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, permission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, permission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, permission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, permission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, permission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, permission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, permission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, permission.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, permission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, permission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, permission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, permission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, permission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, permission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, permission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, permission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, permission.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, permission.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, permission.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, permission.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, permission.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, permission.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Group != nil {
		predicates = append(predicates, permission.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, permission.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, permission.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, permission.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, permission.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, permission.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, permission.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, permission.GroupLTE(*i.GroupLTE))
	}
	if i.GroupContains != nil {
		predicates = append(predicates, permission.GroupContains(*i.GroupContains))
	}
	if i.GroupHasPrefix != nil {
		predicates = append(predicates, permission.GroupHasPrefix(*i.GroupHasPrefix))
	}
	if i.GroupHasSuffix != nil {
		predicates = append(predicates, permission.GroupHasSuffix(*i.GroupHasSuffix))
	}
	if i.GroupEqualFold != nil {
		predicates = append(predicates, permission.GroupEqualFold(*i.GroupEqualFold))
	}
	if i.GroupContainsFold != nil {
		predicates = append(predicates, permission.GroupContainsFold(*i.GroupContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, permission.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, permission.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, permission.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, permission.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, permission.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, permission.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, permission.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, permission.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, permission.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, permission.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, permission.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, permission.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, permission.NameContainsFold(*i.NameContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, permission.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, permission.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, permission.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, permission.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, permission.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, permission.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, permission.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, permission.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, permission.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, permission.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, permission.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, permission.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, permission.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, permission.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, permission.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, permission.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, permission.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeIsNil {
		predicates = append(predicates, permission.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, permission.TypeNotNil())
	}
	if i.Order != nil {
		predicates = append(predicates, permission.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, permission.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, permission.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, permission.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, permission.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, permission.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, permission.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, permission.OrderLTE(*i.OrderLTE))
	}
	if i.OrderIsNil {
		predicates = append(predicates, permission.OrderIsNil())
	}
	if i.OrderNotNil {
		predicates = append(predicates, permission.OrderNotNil())
	}

	if i.HasRoles != nil {
		p := permission.HasRoles()
		if !*i.HasRoles {
			p = permission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, permission.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return permission.And(predicates...), nil
	}
}

// RegionWhereInput represents a where input for filtering Region queries.
type RegionWhereInput struct {
	Predicates []predicate.Region  `json:"-"`
	Not        *RegionWhereInput   `json:"not,omitempty"`
	Or         []*RegionWhereInput `json:"or,omitempty"`
	And        []*RegionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "name_id" field predicates.
	NameID             *string  `json:"nameID,omitempty"`
	NameIDNEQ          *string  `json:"nameIDNEQ,omitempty"`
	NameIDIn           []string `json:"nameIDIn,omitempty"`
	NameIDNotIn        []string `json:"nameIDNotIn,omitempty"`
	NameIDGT           *string  `json:"nameIDGT,omitempty"`
	NameIDGTE          *string  `json:"nameIDGTE,omitempty"`
	NameIDLT           *string  `json:"nameIDLT,omitempty"`
	NameIDLTE          *string  `json:"nameIDLTE,omitempty"`
	NameIDContains     *string  `json:"nameIDContains,omitempty"`
	NameIDHasPrefix    *string  `json:"nameIDHasPrefix,omitempty"`
	NameIDHasSuffix    *string  `json:"nameIDHasSuffix,omitempty"`
	NameIDEqualFold    *string  `json:"nameIDEqualFold,omitempty"`
	NameIDContainsFold *string  `json:"nameIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "type" field predicates.
	Type      *region.Type  `json:"type,omitempty"`
	TypeNEQ   *region.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []region.Type `json:"typeIn,omitempty"`
	TypeNotIn []region.Type `json:"typeNotIn,omitempty"`

	// "parent_id" field predicates.
	ParentID             *xid.ID  `json:"parentID,omitempty"`
	ParentIDNEQ          *xid.ID  `json:"parentIDNEQ,omitempty"`
	ParentIDIn           []xid.ID `json:"parentIDIn,omitempty"`
	ParentIDNotIn        []xid.ID `json:"parentIDNotIn,omitempty"`
	ParentIDGT           *xid.ID  `json:"parentIDGT,omitempty"`
	ParentIDGTE          *xid.ID  `json:"parentIDGTE,omitempty"`
	ParentIDLT           *xid.ID  `json:"parentIDLT,omitempty"`
	ParentIDLTE          *xid.ID  `json:"parentIDLTE,omitempty"`
	ParentIDContains     *xid.ID  `json:"parentIDContains,omitempty"`
	ParentIDHasPrefix    *xid.ID  `json:"parentIDHasPrefix,omitempty"`
	ParentIDHasSuffix    *xid.ID  `json:"parentIDHasSuffix,omitempty"`
	ParentIDIsNil        bool     `json:"parentIDIsNil,omitempty"`
	ParentIDNotNil       bool     `json:"parentIDNotNil,omitempty"`
	ParentIDEqualFold    *xid.ID  `json:"parentIDEqualFold,omitempty"`
	ParentIDContainsFold *xid.ID  `json:"parentIDContainsFold,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool               `json:"hasParent,omitempty"`
	HasParentWith []*RegionWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool               `json:"hasChildren,omitempty"`
	HasChildrenWith []*RegionWhereInput `json:"hasChildrenWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RegionWhereInput) AddPredicates(predicates ...predicate.Region) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RegionWhereInput filter on the RegionQuery builder.
func (i *RegionWhereInput) Filter(q *RegionQuery) (*RegionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRegionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRegionWhereInput is returned in case the RegionWhereInput is empty.
var ErrEmptyRegionWhereInput = errors.New("ent: empty predicate RegionWhereInput")

// P returns a predicate for filtering regions.
// An error is returned if the input is empty or invalid.
func (i *RegionWhereInput) P() (predicate.Region, error) {
	var predicates []predicate.Region
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, region.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Region, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, region.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Region, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, region.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, region.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, region.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, region.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, region.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, region.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, region.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, region.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, region.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, region.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, region.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, region.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, region.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, region.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, region.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, region.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, region.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, region.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, region.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, region.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, region.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, region.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, region.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, region.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, region.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, region.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, region.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, region.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, region.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, region.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, region.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, region.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, region.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, region.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, region.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.NameID != nil {
		predicates = append(predicates, region.NameIDEQ(*i.NameID))
	}
	if i.NameIDNEQ != nil {
		predicates = append(predicates, region.NameIDNEQ(*i.NameIDNEQ))
	}
	if len(i.NameIDIn) > 0 {
		predicates = append(predicates, region.NameIDIn(i.NameIDIn...))
	}
	if len(i.NameIDNotIn) > 0 {
		predicates = append(predicates, region.NameIDNotIn(i.NameIDNotIn...))
	}
	if i.NameIDGT != nil {
		predicates = append(predicates, region.NameIDGT(*i.NameIDGT))
	}
	if i.NameIDGTE != nil {
		predicates = append(predicates, region.NameIDGTE(*i.NameIDGTE))
	}
	if i.NameIDLT != nil {
		predicates = append(predicates, region.NameIDLT(*i.NameIDLT))
	}
	if i.NameIDLTE != nil {
		predicates = append(predicates, region.NameIDLTE(*i.NameIDLTE))
	}
	if i.NameIDContains != nil {
		predicates = append(predicates, region.NameIDContains(*i.NameIDContains))
	}
	if i.NameIDHasPrefix != nil {
		predicates = append(predicates, region.NameIDHasPrefix(*i.NameIDHasPrefix))
	}
	if i.NameIDHasSuffix != nil {
		predicates = append(predicates, region.NameIDHasSuffix(*i.NameIDHasSuffix))
	}
	if i.NameIDEqualFold != nil {
		predicates = append(predicates, region.NameIDEqualFold(*i.NameIDEqualFold))
	}
	if i.NameIDContainsFold != nil {
		predicates = append(predicates, region.NameIDContainsFold(*i.NameIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, region.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, region.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, region.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, region.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, region.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, region.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, region.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, region.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, region.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, region.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, region.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, region.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, region.NameContainsFold(*i.NameContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, region.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, region.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, region.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, region.TypeNotIn(i.TypeNotIn...))
	}
	if i.ParentID != nil {
		predicates = append(predicates, region.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, region.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, region.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, region.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.ParentIDGT != nil {
		predicates = append(predicates, region.ParentIDGT(*i.ParentIDGT))
	}
	if i.ParentIDGTE != nil {
		predicates = append(predicates, region.ParentIDGTE(*i.ParentIDGTE))
	}
	if i.ParentIDLT != nil {
		predicates = append(predicates, region.ParentIDLT(*i.ParentIDLT))
	}
	if i.ParentIDLTE != nil {
		predicates = append(predicates, region.ParentIDLTE(*i.ParentIDLTE))
	}
	if i.ParentIDContains != nil {
		predicates = append(predicates, region.ParentIDContains(*i.ParentIDContains))
	}
	if i.ParentIDHasPrefix != nil {
		predicates = append(predicates, region.ParentIDHasPrefix(*i.ParentIDHasPrefix))
	}
	if i.ParentIDHasSuffix != nil {
		predicates = append(predicates, region.ParentIDHasSuffix(*i.ParentIDHasSuffix))
	}
	if i.ParentIDIsNil {
		predicates = append(predicates, region.ParentIDIsNil())
	}
	if i.ParentIDNotNil {
		predicates = append(predicates, region.ParentIDNotNil())
	}
	if i.ParentIDEqualFold != nil {
		predicates = append(predicates, region.ParentIDEqualFold(*i.ParentIDEqualFold))
	}
	if i.ParentIDContainsFold != nil {
		predicates = append(predicates, region.ParentIDContainsFold(*i.ParentIDContainsFold))
	}

	if i.HasParent != nil {
		p := region.HasParent()
		if !*i.HasParent {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := region.HasChildren()
		if !*i.HasChildren {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasChildrenWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRegionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return region.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "is_changeable" field predicates.
	IsChangeable    *bool `json:"isChangeable,omitempty"`
	IsChangeableNEQ *bool `json:"isChangeableNEQ,omitempty"`

	// "admins" edge predicates.
	HasAdmins     *bool              `json:"hasAdmins,omitempty"`
	HasAdminsWith []*AdminWhereInput `json:"hasAdminsWith,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`

	// "routes" edge predicates.
	HasRoutes     *bool             `json:"hasRoutes,omitempty"`
	HasRoutesWith []*MenuWhereInput `json:"hasRoutesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, role.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, role.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, role.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, role.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, role.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, role.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, role.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, role.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, role.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, role.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, role.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, role.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, role.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, role.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, role.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, role.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, role.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, role.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, role.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, role.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, role.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, role.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, role.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, role.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, role.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, role.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, role.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, role.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, role.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, role.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, role.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, role.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, role.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, role.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, role.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, role.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, role.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, role.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, role.OrderLTE(*i.OrderLTE))
	}
	if i.IsChangeable != nil {
		predicates = append(predicates, role.IsChangeableEQ(*i.IsChangeable))
	}
	if i.IsChangeableNEQ != nil {
		predicates = append(predicates, role.IsChangeableNEQ(*i.IsChangeableNEQ))
	}

	if i.HasAdmins != nil {
		p := role.HasAdmins()
		if !*i.HasAdmins {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAdminsWith) > 0 {
		with := make([]predicate.Admin, 0, len(i.HasAdminsWith))
		for _, w := range i.HasAdminsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAdminsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasAdminsWith(with...))
	}
	if i.HasPermissions != nil {
		p := role.HasPermissions()
		if !*i.HasPermissions {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasPermissionsWith(with...))
	}
	if i.HasRoutes != nil {
		p := role.HasRoutes()
		if !*i.HasRoutes {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutesWith) > 0 {
		with := make([]predicate.Menu, 0, len(i.HasRoutesWith))
		for _, w := range i.HasRoutesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasRoutesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}
