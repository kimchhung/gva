// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/gva/app/database/schema/pulid"
	"github.com/gva/internal/ent/admin"
	"github.com/gva/internal/ent/comic"
	"github.com/gva/internal/ent/comicchapter"
	"github.com/gva/internal/ent/comicimg"
	"github.com/gva/internal/ent/genre"
	"github.com/gva/internal/ent/permission"
	"github.com/gva/internal/ent/predicate"
	"github.com/gva/internal/ent/role"
	"github.com/gva/internal/ent/route"
)

// AdminWhereInput represents a where input for filtering Admin queries.
type AdminWhereInput struct {
	Predicates []predicate.Admin  `json:"-"`
	Not        *AdminWhereInput   `json:"not,omitempty"`
	Or         []*AdminWhereInput `json:"or,omitempty"`
	And        []*AdminWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AdminWhereInput) AddPredicates(predicates ...predicate.Admin) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AdminWhereInput filter on the AdminQuery builder.
func (i *AdminWhereInput) Filter(q *AdminQuery) (*AdminQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAdminWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAdminWhereInput is returned in case the AdminWhereInput is empty.
var ErrEmptyAdminWhereInput = errors.New("ent: empty predicate AdminWhereInput")

// P returns a predicate for filtering admins.
// An error is returned if the input is empty or invalid.
func (i *AdminWhereInput) P() (predicate.Admin, error) {
	var predicates []predicate.Admin
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, admin.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Admin, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, admin.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Admin, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, admin.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, admin.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, admin.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, admin.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, admin.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, admin.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, admin.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, admin.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, admin.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, admin.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, admin.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, admin.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, admin.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, admin.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, admin.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, admin.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, admin.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, admin.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, admin.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, admin.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, admin.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, admin.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, admin.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, admin.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, admin.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, admin.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, admin.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, admin.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, admin.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, admin.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, admin.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, admin.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, admin.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, admin.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, admin.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, admin.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, admin.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, admin.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, admin.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, admin.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, admin.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, admin.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, admin.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, admin.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, admin.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, admin.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, admin.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, admin.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, admin.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, admin.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, admin.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, admin.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, admin.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, admin.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, admin.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, admin.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, admin.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, admin.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, admin.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, admin.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, admin.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, admin.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, admin.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, admin.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, admin.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, admin.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, admin.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, admin.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, admin.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, admin.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, admin.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, admin.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, admin.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, admin.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, admin.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, admin.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	if i.HasRoles != nil {
		p := admin.HasRoles()
		if !*i.HasRoles {
			p = admin.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, admin.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAdminWhereInput
	case 1:
		return predicates[0], nil
	default:
		return admin.And(predicates...), nil
	}
}

// ComicWhereInput represents a where input for filtering Comic queries.
type ComicWhereInput struct {
	Predicates []predicate.Comic  `json:"-"`
	Not        *ComicWhereInput   `json:"not,omitempty"`
	Or         []*ComicWhereInput `json:"or,omitempty"`
	And        []*ComicWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "chapter" field predicates.
	Chapter      *uint  `json:"chapter,omitempty"`
	ChapterNEQ   *uint  `json:"chapterNEQ,omitempty"`
	ChapterIn    []uint `json:"chapterIn,omitempty"`
	ChapterNotIn []uint `json:"chapterNotIn,omitempty"`
	ChapterGT    *uint  `json:"chapterGT,omitempty"`
	ChapterGTE   *uint  `json:"chapterGTE,omitempty"`
	ChapterLT    *uint  `json:"chapterLT,omitempty"`
	ChapterLTE   *uint  `json:"chapterLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "isTranslateCompleted" field predicates.
	IsTranslateCompleted    *bool `json:"istranslatecompleted,omitempty"`
	IsTranslateCompletedNEQ *bool `json:"istranslatecompletedNEQ,omitempty"`

	// "up_count" field predicates.
	UpCount      *uint  `json:"upCount,omitempty"`
	UpCountNEQ   *uint  `json:"upCountNEQ,omitempty"`
	UpCountIn    []uint `json:"upCountIn,omitempty"`
	UpCountNotIn []uint `json:"upCountNotIn,omitempty"`
	UpCountGT    *uint  `json:"upCountGT,omitempty"`
	UpCountGTE   *uint  `json:"upCountGTE,omitempty"`
	UpCountLT    *uint  `json:"upCountLT,omitempty"`
	UpCountLTE   *uint  `json:"upCountLTE,omitempty"`

	// "final_chapter_id" field predicates.
	FinalChapterID             *pulid.ID  `json:"finalChapterID,omitempty"`
	FinalChapterIDNEQ          *pulid.ID  `json:"finalChapterIDNEQ,omitempty"`
	FinalChapterIDIn           []pulid.ID `json:"finalChapterIDIn,omitempty"`
	FinalChapterIDNotIn        []pulid.ID `json:"finalChapterIDNotIn,omitempty"`
	FinalChapterIDGT           *pulid.ID  `json:"finalChapterIDGT,omitempty"`
	FinalChapterIDGTE          *pulid.ID  `json:"finalChapterIDGTE,omitempty"`
	FinalChapterIDLT           *pulid.ID  `json:"finalChapterIDLT,omitempty"`
	FinalChapterIDLTE          *pulid.ID  `json:"finalChapterIDLTE,omitempty"`
	FinalChapterIDContains     *pulid.ID  `json:"finalChapterIDContains,omitempty"`
	FinalChapterIDHasPrefix    *pulid.ID  `json:"finalChapterIDHasPrefix,omitempty"`
	FinalChapterIDHasSuffix    *pulid.ID  `json:"finalChapterIDHasSuffix,omitempty"`
	FinalChapterIDIsNil        bool       `json:"finalChapterIDIsNil,omitempty"`
	FinalChapterIDNotNil       bool       `json:"finalChapterIDNotNil,omitempty"`
	FinalChapterIDEqualFold    *pulid.ID  `json:"finalChapterIDEqualFold,omitempty"`
	FinalChapterIDContainsFold *pulid.ID  `json:"finalChapterIDContainsFold,omitempty"`

	// "last_chapter_id" field predicates.
	LastChapterID             *pulid.ID  `json:"lastChapterID,omitempty"`
	LastChapterIDNEQ          *pulid.ID  `json:"lastChapterIDNEQ,omitempty"`
	LastChapterIDIn           []pulid.ID `json:"lastChapterIDIn,omitempty"`
	LastChapterIDNotIn        []pulid.ID `json:"lastChapterIDNotIn,omitempty"`
	LastChapterIDGT           *pulid.ID  `json:"lastChapterIDGT,omitempty"`
	LastChapterIDGTE          *pulid.ID  `json:"lastChapterIDGTE,omitempty"`
	LastChapterIDLT           *pulid.ID  `json:"lastChapterIDLT,omitempty"`
	LastChapterIDLTE          *pulid.ID  `json:"lastChapterIDLTE,omitempty"`
	LastChapterIDContains     *pulid.ID  `json:"lastChapterIDContains,omitempty"`
	LastChapterIDHasPrefix    *pulid.ID  `json:"lastChapterIDHasPrefix,omitempty"`
	LastChapterIDHasSuffix    *pulid.ID  `json:"lastChapterIDHasSuffix,omitempty"`
	LastChapterIDIsNil        bool       `json:"lastChapterIDIsNil,omitempty"`
	LastChapterIDNotNil       bool       `json:"lastChapterIDNotNil,omitempty"`
	LastChapterIDEqualFold    *pulid.ID  `json:"lastChapterIDEqualFold,omitempty"`
	LastChapterIDContainsFold *pulid.ID  `json:"lastChapterIDContainsFold,omitempty"`

	// "chapters" edge predicates.
	HasChapters     *bool                     `json:"hasChapters,omitempty"`
	HasChaptersWith []*ComicChapterWhereInput `json:"hasChaptersWith,omitempty"`

	// "last_chapter" edge predicates.
	HasLastChapter     *bool                     `json:"hasLastChapter,omitempty"`
	HasLastChapterWith []*ComicChapterWhereInput `json:"hasLastChapterWith,omitempty"`

	// "final_chapter" edge predicates.
	HasFinalChapter     *bool                     `json:"hasFinalChapter,omitempty"`
	HasFinalChapterWith []*ComicChapterWhereInput `json:"hasFinalChapterWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ComicWhereInput) AddPredicates(predicates ...predicate.Comic) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ComicWhereInput filter on the ComicQuery builder.
func (i *ComicWhereInput) Filter(q *ComicQuery) (*ComicQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyComicWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyComicWhereInput is returned in case the ComicWhereInput is empty.
var ErrEmptyComicWhereInput = errors.New("ent: empty predicate ComicWhereInput")

// P returns a predicate for filtering comics.
// An error is returned if the input is empty or invalid.
func (i *ComicWhereInput) P() (predicate.Comic, error) {
	var predicates []predicate.Comic
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, comic.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Comic, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, comic.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Comic, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, comic.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, comic.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, comic.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, comic.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, comic.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, comic.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, comic.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, comic.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, comic.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, comic.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, comic.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, comic.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, comic.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, comic.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, comic.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, comic.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, comic.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, comic.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, comic.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, comic.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, comic.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, comic.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, comic.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, comic.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, comic.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Chapter != nil {
		predicates = append(predicates, comic.ChapterEQ(*i.Chapter))
	}
	if i.ChapterNEQ != nil {
		predicates = append(predicates, comic.ChapterNEQ(*i.ChapterNEQ))
	}
	if len(i.ChapterIn) > 0 {
		predicates = append(predicates, comic.ChapterIn(i.ChapterIn...))
	}
	if len(i.ChapterNotIn) > 0 {
		predicates = append(predicates, comic.ChapterNotIn(i.ChapterNotIn...))
	}
	if i.ChapterGT != nil {
		predicates = append(predicates, comic.ChapterGT(*i.ChapterGT))
	}
	if i.ChapterGTE != nil {
		predicates = append(predicates, comic.ChapterGTE(*i.ChapterGTE))
	}
	if i.ChapterLT != nil {
		predicates = append(predicates, comic.ChapterLT(*i.ChapterLT))
	}
	if i.ChapterLTE != nil {
		predicates = append(predicates, comic.ChapterLTE(*i.ChapterLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, comic.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, comic.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, comic.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, comic.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, comic.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, comic.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, comic.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, comic.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, comic.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, comic.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, comic.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, comic.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, comic.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, comic.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, comic.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, comic.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, comic.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, comic.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, comic.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, comic.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, comic.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, comic.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, comic.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, comic.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, comic.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, comic.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, comic.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, comic.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, comic.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, comic.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, comic.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, comic.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, comic.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, comic.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, comic.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, comic.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, comic.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, comic.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, comic.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.IsTranslateCompleted != nil {
		predicates = append(predicates, comic.IsTranslateCompletedEQ(*i.IsTranslateCompleted))
	}
	if i.IsTranslateCompletedNEQ != nil {
		predicates = append(predicates, comic.IsTranslateCompletedNEQ(*i.IsTranslateCompletedNEQ))
	}
	if i.UpCount != nil {
		predicates = append(predicates, comic.UpCountEQ(*i.UpCount))
	}
	if i.UpCountNEQ != nil {
		predicates = append(predicates, comic.UpCountNEQ(*i.UpCountNEQ))
	}
	if len(i.UpCountIn) > 0 {
		predicates = append(predicates, comic.UpCountIn(i.UpCountIn...))
	}
	if len(i.UpCountNotIn) > 0 {
		predicates = append(predicates, comic.UpCountNotIn(i.UpCountNotIn...))
	}
	if i.UpCountGT != nil {
		predicates = append(predicates, comic.UpCountGT(*i.UpCountGT))
	}
	if i.UpCountGTE != nil {
		predicates = append(predicates, comic.UpCountGTE(*i.UpCountGTE))
	}
	if i.UpCountLT != nil {
		predicates = append(predicates, comic.UpCountLT(*i.UpCountLT))
	}
	if i.UpCountLTE != nil {
		predicates = append(predicates, comic.UpCountLTE(*i.UpCountLTE))
	}
	if i.FinalChapterID != nil {
		predicates = append(predicates, comic.FinalChapterIDEQ(*i.FinalChapterID))
	}
	if i.FinalChapterIDNEQ != nil {
		predicates = append(predicates, comic.FinalChapterIDNEQ(*i.FinalChapterIDNEQ))
	}
	if len(i.FinalChapterIDIn) > 0 {
		predicates = append(predicates, comic.FinalChapterIDIn(i.FinalChapterIDIn...))
	}
	if len(i.FinalChapterIDNotIn) > 0 {
		predicates = append(predicates, comic.FinalChapterIDNotIn(i.FinalChapterIDNotIn...))
	}
	if i.FinalChapterIDGT != nil {
		predicates = append(predicates, comic.FinalChapterIDGT(*i.FinalChapterIDGT))
	}
	if i.FinalChapterIDGTE != nil {
		predicates = append(predicates, comic.FinalChapterIDGTE(*i.FinalChapterIDGTE))
	}
	if i.FinalChapterIDLT != nil {
		predicates = append(predicates, comic.FinalChapterIDLT(*i.FinalChapterIDLT))
	}
	if i.FinalChapterIDLTE != nil {
		predicates = append(predicates, comic.FinalChapterIDLTE(*i.FinalChapterIDLTE))
	}
	if i.FinalChapterIDContains != nil {
		predicates = append(predicates, comic.FinalChapterIDContains(*i.FinalChapterIDContains))
	}
	if i.FinalChapterIDHasPrefix != nil {
		predicates = append(predicates, comic.FinalChapterIDHasPrefix(*i.FinalChapterIDHasPrefix))
	}
	if i.FinalChapterIDHasSuffix != nil {
		predicates = append(predicates, comic.FinalChapterIDHasSuffix(*i.FinalChapterIDHasSuffix))
	}
	if i.FinalChapterIDIsNil {
		predicates = append(predicates, comic.FinalChapterIDIsNil())
	}
	if i.FinalChapterIDNotNil {
		predicates = append(predicates, comic.FinalChapterIDNotNil())
	}
	if i.FinalChapterIDEqualFold != nil {
		predicates = append(predicates, comic.FinalChapterIDEqualFold(*i.FinalChapterIDEqualFold))
	}
	if i.FinalChapterIDContainsFold != nil {
		predicates = append(predicates, comic.FinalChapterIDContainsFold(*i.FinalChapterIDContainsFold))
	}
	if i.LastChapterID != nil {
		predicates = append(predicates, comic.LastChapterIDEQ(*i.LastChapterID))
	}
	if i.LastChapterIDNEQ != nil {
		predicates = append(predicates, comic.LastChapterIDNEQ(*i.LastChapterIDNEQ))
	}
	if len(i.LastChapterIDIn) > 0 {
		predicates = append(predicates, comic.LastChapterIDIn(i.LastChapterIDIn...))
	}
	if len(i.LastChapterIDNotIn) > 0 {
		predicates = append(predicates, comic.LastChapterIDNotIn(i.LastChapterIDNotIn...))
	}
	if i.LastChapterIDGT != nil {
		predicates = append(predicates, comic.LastChapterIDGT(*i.LastChapterIDGT))
	}
	if i.LastChapterIDGTE != nil {
		predicates = append(predicates, comic.LastChapterIDGTE(*i.LastChapterIDGTE))
	}
	if i.LastChapterIDLT != nil {
		predicates = append(predicates, comic.LastChapterIDLT(*i.LastChapterIDLT))
	}
	if i.LastChapterIDLTE != nil {
		predicates = append(predicates, comic.LastChapterIDLTE(*i.LastChapterIDLTE))
	}
	if i.LastChapterIDContains != nil {
		predicates = append(predicates, comic.LastChapterIDContains(*i.LastChapterIDContains))
	}
	if i.LastChapterIDHasPrefix != nil {
		predicates = append(predicates, comic.LastChapterIDHasPrefix(*i.LastChapterIDHasPrefix))
	}
	if i.LastChapterIDHasSuffix != nil {
		predicates = append(predicates, comic.LastChapterIDHasSuffix(*i.LastChapterIDHasSuffix))
	}
	if i.LastChapterIDIsNil {
		predicates = append(predicates, comic.LastChapterIDIsNil())
	}
	if i.LastChapterIDNotNil {
		predicates = append(predicates, comic.LastChapterIDNotNil())
	}
	if i.LastChapterIDEqualFold != nil {
		predicates = append(predicates, comic.LastChapterIDEqualFold(*i.LastChapterIDEqualFold))
	}
	if i.LastChapterIDContainsFold != nil {
		predicates = append(predicates, comic.LastChapterIDContainsFold(*i.LastChapterIDContainsFold))
	}

	if i.HasChapters != nil {
		p := comic.HasChapters()
		if !*i.HasChapters {
			p = comic.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChaptersWith) > 0 {
		with := make([]predicate.ComicChapter, 0, len(i.HasChaptersWith))
		for _, w := range i.HasChaptersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChaptersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comic.HasChaptersWith(with...))
	}
	if i.HasLastChapter != nil {
		p := comic.HasLastChapter()
		if !*i.HasLastChapter {
			p = comic.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLastChapterWith) > 0 {
		with := make([]predicate.ComicChapter, 0, len(i.HasLastChapterWith))
		for _, w := range i.HasLastChapterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLastChapterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comic.HasLastChapterWith(with...))
	}
	if i.HasFinalChapter != nil {
		p := comic.HasFinalChapter()
		if !*i.HasFinalChapter {
			p = comic.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFinalChapterWith) > 0 {
		with := make([]predicate.ComicChapter, 0, len(i.HasFinalChapterWith))
		for _, w := range i.HasFinalChapterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFinalChapterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comic.HasFinalChapterWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyComicWhereInput
	case 1:
		return predicates[0], nil
	default:
		return comic.And(predicates...), nil
	}
}

// ComicChapterWhereInput represents a where input for filtering ComicChapter queries.
type ComicChapterWhereInput struct {
	Predicates []predicate.ComicChapter  `json:"-"`
	Not        *ComicChapterWhereInput   `json:"not,omitempty"`
	Or         []*ComicChapterWhereInput `json:"or,omitempty"`
	And        []*ComicChapterWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "chapter" field predicates.
	Chapter      *uint  `json:"chapter,omitempty"`
	ChapterNEQ   *uint  `json:"chapterNEQ,omitempty"`
	ChapterIn    []uint `json:"chapterIn,omitempty"`
	ChapterNotIn []uint `json:"chapterNotIn,omitempty"`
	ChapterGT    *uint  `json:"chapterGT,omitempty"`
	ChapterGTE   *uint  `json:"chapterGTE,omitempty"`
	ChapterLT    *uint  `json:"chapterLT,omitempty"`
	ChapterLTE   *uint  `json:"chapterLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "volumn" field predicates.
	Volumn             *string  `json:"volumn,omitempty"`
	VolumnNEQ          *string  `json:"volumnNEQ,omitempty"`
	VolumnIn           []string `json:"volumnIn,omitempty"`
	VolumnNotIn        []string `json:"volumnNotIn,omitempty"`
	VolumnGT           *string  `json:"volumnGT,omitempty"`
	VolumnGTE          *string  `json:"volumnGTE,omitempty"`
	VolumnLT           *string  `json:"volumnLT,omitempty"`
	VolumnLTE          *string  `json:"volumnLTE,omitempty"`
	VolumnContains     *string  `json:"volumnContains,omitempty"`
	VolumnHasPrefix    *string  `json:"volumnHasPrefix,omitempty"`
	VolumnHasSuffix    *string  `json:"volumnHasSuffix,omitempty"`
	VolumnIsNil        bool     `json:"volumnIsNil,omitempty"`
	VolumnNotNil       bool     `json:"volumnNotNil,omitempty"`
	VolumnEqualFold    *string  `json:"volumnEqualFold,omitempty"`
	VolumnContainsFold *string  `json:"volumnContainsFold,omitempty"`

	// "lang" field predicates.
	Lang             *string  `json:"lang,omitempty"`
	LangNEQ          *string  `json:"langNEQ,omitempty"`
	LangIn           []string `json:"langIn,omitempty"`
	LangNotIn        []string `json:"langNotIn,omitempty"`
	LangGT           *string  `json:"langGT,omitempty"`
	LangGTE          *string  `json:"langGTE,omitempty"`
	LangLT           *string  `json:"langLT,omitempty"`
	LangLTE          *string  `json:"langLTE,omitempty"`
	LangContains     *string  `json:"langContains,omitempty"`
	LangHasPrefix    *string  `json:"langHasPrefix,omitempty"`
	LangHasSuffix    *string  `json:"langHasSuffix,omitempty"`
	LangEqualFold    *string  `json:"langEqualFold,omitempty"`
	LangContainsFold *string  `json:"langContainsFold,omitempty"`

	// "up_count" field predicates.
	UpCount      *uint  `json:"upCount,omitempty"`
	UpCountNEQ   *uint  `json:"upCountNEQ,omitempty"`
	UpCountIn    []uint `json:"upCountIn,omitempty"`
	UpCountNotIn []uint `json:"upCountNotIn,omitempty"`
	UpCountGT    *uint  `json:"upCountGT,omitempty"`
	UpCountGTE   *uint  `json:"upCountGTE,omitempty"`
	UpCountLT    *uint  `json:"upCountLT,omitempty"`
	UpCountLTE   *uint  `json:"upCountLTE,omitempty"`

	// "down_count" field predicates.
	DownCount      *uint  `json:"downCount,omitempty"`
	DownCountNEQ   *uint  `json:"downCountNEQ,omitempty"`
	DownCountIn    []uint `json:"downCountIn,omitempty"`
	DownCountNotIn []uint `json:"downCountNotIn,omitempty"`
	DownCountGT    *uint  `json:"downCountGT,omitempty"`
	DownCountGTE   *uint  `json:"downCountGTE,omitempty"`
	DownCountLT    *uint  `json:"downCountLT,omitempty"`
	DownCountLTE   *uint  `json:"downCountLTE,omitempty"`

	// "is_last_chapter" field predicates.
	IsLastChapter    *bool `json:"isLastChapter,omitempty"`
	IsLastChapterNEQ *bool `json:"isLastChapterNEQ,omitempty"`

	// "imgs" edge predicates.
	HasImgs     *bool                 `json:"hasImgs,omitempty"`
	HasImgsWith []*ComicImgWhereInput `json:"hasImgsWith,omitempty"`

	// "comic" edge predicates.
	HasComic     *bool              `json:"hasComic,omitempty"`
	HasComicWith []*ComicWhereInput `json:"hasComicWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ComicChapterWhereInput) AddPredicates(predicates ...predicate.ComicChapter) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ComicChapterWhereInput filter on the ComicChapterQuery builder.
func (i *ComicChapterWhereInput) Filter(q *ComicChapterQuery) (*ComicChapterQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyComicChapterWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyComicChapterWhereInput is returned in case the ComicChapterWhereInput is empty.
var ErrEmptyComicChapterWhereInput = errors.New("ent: empty predicate ComicChapterWhereInput")

// P returns a predicate for filtering comicchapters.
// An error is returned if the input is empty or invalid.
func (i *ComicChapterWhereInput) P() (predicate.ComicChapter, error) {
	var predicates []predicate.ComicChapter
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, comicchapter.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ComicChapter, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, comicchapter.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ComicChapter, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, comicchapter.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, comicchapter.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, comicchapter.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, comicchapter.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, comicchapter.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, comicchapter.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, comicchapter.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, comicchapter.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, comicchapter.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, comicchapter.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, comicchapter.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, comicchapter.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, comicchapter.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, comicchapter.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, comicchapter.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, comicchapter.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, comicchapter.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, comicchapter.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, comicchapter.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, comicchapter.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, comicchapter.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, comicchapter.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, comicchapter.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, comicchapter.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, comicchapter.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Chapter != nil {
		predicates = append(predicates, comicchapter.ChapterEQ(*i.Chapter))
	}
	if i.ChapterNEQ != nil {
		predicates = append(predicates, comicchapter.ChapterNEQ(*i.ChapterNEQ))
	}
	if len(i.ChapterIn) > 0 {
		predicates = append(predicates, comicchapter.ChapterIn(i.ChapterIn...))
	}
	if len(i.ChapterNotIn) > 0 {
		predicates = append(predicates, comicchapter.ChapterNotIn(i.ChapterNotIn...))
	}
	if i.ChapterGT != nil {
		predicates = append(predicates, comicchapter.ChapterGT(*i.ChapterGT))
	}
	if i.ChapterGTE != nil {
		predicates = append(predicates, comicchapter.ChapterGTE(*i.ChapterGTE))
	}
	if i.ChapterLT != nil {
		predicates = append(predicates, comicchapter.ChapterLT(*i.ChapterLT))
	}
	if i.ChapterLTE != nil {
		predicates = append(predicates, comicchapter.ChapterLTE(*i.ChapterLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, comicchapter.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, comicchapter.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, comicchapter.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, comicchapter.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, comicchapter.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, comicchapter.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, comicchapter.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, comicchapter.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, comicchapter.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, comicchapter.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, comicchapter.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, comicchapter.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, comicchapter.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, comicchapter.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, comicchapter.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Volumn != nil {
		predicates = append(predicates, comicchapter.VolumnEQ(*i.Volumn))
	}
	if i.VolumnNEQ != nil {
		predicates = append(predicates, comicchapter.VolumnNEQ(*i.VolumnNEQ))
	}
	if len(i.VolumnIn) > 0 {
		predicates = append(predicates, comicchapter.VolumnIn(i.VolumnIn...))
	}
	if len(i.VolumnNotIn) > 0 {
		predicates = append(predicates, comicchapter.VolumnNotIn(i.VolumnNotIn...))
	}
	if i.VolumnGT != nil {
		predicates = append(predicates, comicchapter.VolumnGT(*i.VolumnGT))
	}
	if i.VolumnGTE != nil {
		predicates = append(predicates, comicchapter.VolumnGTE(*i.VolumnGTE))
	}
	if i.VolumnLT != nil {
		predicates = append(predicates, comicchapter.VolumnLT(*i.VolumnLT))
	}
	if i.VolumnLTE != nil {
		predicates = append(predicates, comicchapter.VolumnLTE(*i.VolumnLTE))
	}
	if i.VolumnContains != nil {
		predicates = append(predicates, comicchapter.VolumnContains(*i.VolumnContains))
	}
	if i.VolumnHasPrefix != nil {
		predicates = append(predicates, comicchapter.VolumnHasPrefix(*i.VolumnHasPrefix))
	}
	if i.VolumnHasSuffix != nil {
		predicates = append(predicates, comicchapter.VolumnHasSuffix(*i.VolumnHasSuffix))
	}
	if i.VolumnIsNil {
		predicates = append(predicates, comicchapter.VolumnIsNil())
	}
	if i.VolumnNotNil {
		predicates = append(predicates, comicchapter.VolumnNotNil())
	}
	if i.VolumnEqualFold != nil {
		predicates = append(predicates, comicchapter.VolumnEqualFold(*i.VolumnEqualFold))
	}
	if i.VolumnContainsFold != nil {
		predicates = append(predicates, comicchapter.VolumnContainsFold(*i.VolumnContainsFold))
	}
	if i.Lang != nil {
		predicates = append(predicates, comicchapter.LangEQ(*i.Lang))
	}
	if i.LangNEQ != nil {
		predicates = append(predicates, comicchapter.LangNEQ(*i.LangNEQ))
	}
	if len(i.LangIn) > 0 {
		predicates = append(predicates, comicchapter.LangIn(i.LangIn...))
	}
	if len(i.LangNotIn) > 0 {
		predicates = append(predicates, comicchapter.LangNotIn(i.LangNotIn...))
	}
	if i.LangGT != nil {
		predicates = append(predicates, comicchapter.LangGT(*i.LangGT))
	}
	if i.LangGTE != nil {
		predicates = append(predicates, comicchapter.LangGTE(*i.LangGTE))
	}
	if i.LangLT != nil {
		predicates = append(predicates, comicchapter.LangLT(*i.LangLT))
	}
	if i.LangLTE != nil {
		predicates = append(predicates, comicchapter.LangLTE(*i.LangLTE))
	}
	if i.LangContains != nil {
		predicates = append(predicates, comicchapter.LangContains(*i.LangContains))
	}
	if i.LangHasPrefix != nil {
		predicates = append(predicates, comicchapter.LangHasPrefix(*i.LangHasPrefix))
	}
	if i.LangHasSuffix != nil {
		predicates = append(predicates, comicchapter.LangHasSuffix(*i.LangHasSuffix))
	}
	if i.LangEqualFold != nil {
		predicates = append(predicates, comicchapter.LangEqualFold(*i.LangEqualFold))
	}
	if i.LangContainsFold != nil {
		predicates = append(predicates, comicchapter.LangContainsFold(*i.LangContainsFold))
	}
	if i.UpCount != nil {
		predicates = append(predicates, comicchapter.UpCountEQ(*i.UpCount))
	}
	if i.UpCountNEQ != nil {
		predicates = append(predicates, comicchapter.UpCountNEQ(*i.UpCountNEQ))
	}
	if len(i.UpCountIn) > 0 {
		predicates = append(predicates, comicchapter.UpCountIn(i.UpCountIn...))
	}
	if len(i.UpCountNotIn) > 0 {
		predicates = append(predicates, comicchapter.UpCountNotIn(i.UpCountNotIn...))
	}
	if i.UpCountGT != nil {
		predicates = append(predicates, comicchapter.UpCountGT(*i.UpCountGT))
	}
	if i.UpCountGTE != nil {
		predicates = append(predicates, comicchapter.UpCountGTE(*i.UpCountGTE))
	}
	if i.UpCountLT != nil {
		predicates = append(predicates, comicchapter.UpCountLT(*i.UpCountLT))
	}
	if i.UpCountLTE != nil {
		predicates = append(predicates, comicchapter.UpCountLTE(*i.UpCountLTE))
	}
	if i.DownCount != nil {
		predicates = append(predicates, comicchapter.DownCountEQ(*i.DownCount))
	}
	if i.DownCountNEQ != nil {
		predicates = append(predicates, comicchapter.DownCountNEQ(*i.DownCountNEQ))
	}
	if len(i.DownCountIn) > 0 {
		predicates = append(predicates, comicchapter.DownCountIn(i.DownCountIn...))
	}
	if len(i.DownCountNotIn) > 0 {
		predicates = append(predicates, comicchapter.DownCountNotIn(i.DownCountNotIn...))
	}
	if i.DownCountGT != nil {
		predicates = append(predicates, comicchapter.DownCountGT(*i.DownCountGT))
	}
	if i.DownCountGTE != nil {
		predicates = append(predicates, comicchapter.DownCountGTE(*i.DownCountGTE))
	}
	if i.DownCountLT != nil {
		predicates = append(predicates, comicchapter.DownCountLT(*i.DownCountLT))
	}
	if i.DownCountLTE != nil {
		predicates = append(predicates, comicchapter.DownCountLTE(*i.DownCountLTE))
	}
	if i.IsLastChapter != nil {
		predicates = append(predicates, comicchapter.IsLastChapterEQ(*i.IsLastChapter))
	}
	if i.IsLastChapterNEQ != nil {
		predicates = append(predicates, comicchapter.IsLastChapterNEQ(*i.IsLastChapterNEQ))
	}

	if i.HasImgs != nil {
		p := comicchapter.HasImgs()
		if !*i.HasImgs {
			p = comicchapter.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImgsWith) > 0 {
		with := make([]predicate.ComicImg, 0, len(i.HasImgsWith))
		for _, w := range i.HasImgsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasImgsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comicchapter.HasImgsWith(with...))
	}
	if i.HasComic != nil {
		p := comicchapter.HasComic()
		if !*i.HasComic {
			p = comicchapter.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComicWith) > 0 {
		with := make([]predicate.Comic, 0, len(i.HasComicWith))
		for _, w := range i.HasComicWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasComicWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comicchapter.HasComicWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyComicChapterWhereInput
	case 1:
		return predicates[0], nil
	default:
		return comicchapter.And(predicates...), nil
	}
}

// ComicImgWhereInput represents a where input for filtering ComicImg queries.
type ComicImgWhereInput struct {
	Predicates []predicate.ComicImg  `json:"-"`
	Not        *ComicImgWhereInput   `json:"not,omitempty"`
	Or         []*ComicImgWhereInput `json:"or,omitempty"`
	And        []*ComicImgWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "b2key" field predicates.
	B2key             *string  `json:"b2key,omitempty"`
	B2keyNEQ          *string  `json:"b2keyNEQ,omitempty"`
	B2keyIn           []string `json:"b2keyIn,omitempty"`
	B2keyNotIn        []string `json:"b2keyNotIn,omitempty"`
	B2keyGT           *string  `json:"b2keyGT,omitempty"`
	B2keyGTE          *string  `json:"b2keyGTE,omitempty"`
	B2keyLT           *string  `json:"b2keyLT,omitempty"`
	B2keyLTE          *string  `json:"b2keyLTE,omitempty"`
	B2keyContains     *string  `json:"b2keyContains,omitempty"`
	B2keyHasPrefix    *string  `json:"b2keyHasPrefix,omitempty"`
	B2keyHasSuffix    *string  `json:"b2keyHasSuffix,omitempty"`
	B2keyEqualFold    *string  `json:"b2keyEqualFold,omitempty"`
	B2keyContainsFold *string  `json:"b2keyContainsFold,omitempty"`

	// "height" field predicates.
	Height      *int  `json:"height,omitempty"`
	HeightNEQ   *int  `json:"heightNEQ,omitempty"`
	HeightIn    []int `json:"heightIn,omitempty"`
	HeightNotIn []int `json:"heightNotIn,omitempty"`
	HeightGT    *int  `json:"heightGT,omitempty"`
	HeightGTE   *int  `json:"heightGTE,omitempty"`
	HeightLT    *int  `json:"heightLT,omitempty"`
	HeightLTE   *int  `json:"heightLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "optimized_size" field predicates.
	OptimizedSize      *int64  `json:"optimizedSize,omitempty"`
	OptimizedSizeNEQ   *int64  `json:"optimizedSizeNEQ,omitempty"`
	OptimizedSizeIn    []int64 `json:"optimizedSizeIn,omitempty"`
	OptimizedSizeNotIn []int64 `json:"optimizedSizeNotIn,omitempty"`
	OptimizedSizeGT    *int64  `json:"optimizedSizeGT,omitempty"`
	OptimizedSizeGTE   *int64  `json:"optimizedSizeGTE,omitempty"`
	OptimizedSizeLT    *int64  `json:"optimizedSizeLT,omitempty"`
	OptimizedSizeLTE   *int64  `json:"optimizedSizeLTE,omitempty"`

	// "size" field predicates.
	Size      *int64  `json:"size,omitempty"`
	SizeNEQ   *int64  `json:"sizeNEQ,omitempty"`
	SizeIn    []int64 `json:"sizeIn,omitempty"`
	SizeNotIn []int64 `json:"sizeNotIn,omitempty"`
	SizeGT    *int64  `json:"sizeGT,omitempty"`
	SizeGTE   *int64  `json:"sizeGTE,omitempty"`
	SizeLT    *int64  `json:"sizeLT,omitempty"`
	SizeLTE   *int64  `json:"sizeLTE,omitempty"`

	// "width" field predicates.
	Width      *int  `json:"width,omitempty"`
	WidthNEQ   *int  `json:"widthNEQ,omitempty"`
	WidthIn    []int `json:"widthIn,omitempty"`
	WidthNotIn []int `json:"widthNotIn,omitempty"`
	WidthGT    *int  `json:"widthGT,omitempty"`
	WidthGTE   *int  `json:"widthGTE,omitempty"`
	WidthLT    *int  `json:"widthLT,omitempty"`
	WidthLTE   *int  `json:"widthLTE,omitempty"`

	// "chapter" edge predicates.
	HasChapter     *bool                     `json:"hasChapter,omitempty"`
	HasChapterWith []*ComicChapterWhereInput `json:"hasChapterWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ComicImgWhereInput) AddPredicates(predicates ...predicate.ComicImg) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ComicImgWhereInput filter on the ComicImgQuery builder.
func (i *ComicImgWhereInput) Filter(q *ComicImgQuery) (*ComicImgQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyComicImgWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyComicImgWhereInput is returned in case the ComicImgWhereInput is empty.
var ErrEmptyComicImgWhereInput = errors.New("ent: empty predicate ComicImgWhereInput")

// P returns a predicate for filtering comicimgs.
// An error is returned if the input is empty or invalid.
func (i *ComicImgWhereInput) P() (predicate.ComicImg, error) {
	var predicates []predicate.ComicImg
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, comicimg.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ComicImg, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, comicimg.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ComicImg, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, comicimg.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, comicimg.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, comicimg.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, comicimg.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, comicimg.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, comicimg.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, comicimg.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, comicimg.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, comicimg.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, comicimg.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, comicimg.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, comicimg.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, comicimg.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, comicimg.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, comicimg.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, comicimg.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, comicimg.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, comicimg.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, comicimg.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, comicimg.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, comicimg.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, comicimg.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, comicimg.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, comicimg.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, comicimg.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.B2key != nil {
		predicates = append(predicates, comicimg.B2keyEQ(*i.B2key))
	}
	if i.B2keyNEQ != nil {
		predicates = append(predicates, comicimg.B2keyNEQ(*i.B2keyNEQ))
	}
	if len(i.B2keyIn) > 0 {
		predicates = append(predicates, comicimg.B2keyIn(i.B2keyIn...))
	}
	if len(i.B2keyNotIn) > 0 {
		predicates = append(predicates, comicimg.B2keyNotIn(i.B2keyNotIn...))
	}
	if i.B2keyGT != nil {
		predicates = append(predicates, comicimg.B2keyGT(*i.B2keyGT))
	}
	if i.B2keyGTE != nil {
		predicates = append(predicates, comicimg.B2keyGTE(*i.B2keyGTE))
	}
	if i.B2keyLT != nil {
		predicates = append(predicates, comicimg.B2keyLT(*i.B2keyLT))
	}
	if i.B2keyLTE != nil {
		predicates = append(predicates, comicimg.B2keyLTE(*i.B2keyLTE))
	}
	if i.B2keyContains != nil {
		predicates = append(predicates, comicimg.B2keyContains(*i.B2keyContains))
	}
	if i.B2keyHasPrefix != nil {
		predicates = append(predicates, comicimg.B2keyHasPrefix(*i.B2keyHasPrefix))
	}
	if i.B2keyHasSuffix != nil {
		predicates = append(predicates, comicimg.B2keyHasSuffix(*i.B2keyHasSuffix))
	}
	if i.B2keyEqualFold != nil {
		predicates = append(predicates, comicimg.B2keyEqualFold(*i.B2keyEqualFold))
	}
	if i.B2keyContainsFold != nil {
		predicates = append(predicates, comicimg.B2keyContainsFold(*i.B2keyContainsFold))
	}
	if i.Height != nil {
		predicates = append(predicates, comicimg.HeightEQ(*i.Height))
	}
	if i.HeightNEQ != nil {
		predicates = append(predicates, comicimg.HeightNEQ(*i.HeightNEQ))
	}
	if len(i.HeightIn) > 0 {
		predicates = append(predicates, comicimg.HeightIn(i.HeightIn...))
	}
	if len(i.HeightNotIn) > 0 {
		predicates = append(predicates, comicimg.HeightNotIn(i.HeightNotIn...))
	}
	if i.HeightGT != nil {
		predicates = append(predicates, comicimg.HeightGT(*i.HeightGT))
	}
	if i.HeightGTE != nil {
		predicates = append(predicates, comicimg.HeightGTE(*i.HeightGTE))
	}
	if i.HeightLT != nil {
		predicates = append(predicates, comicimg.HeightLT(*i.HeightLT))
	}
	if i.HeightLTE != nil {
		predicates = append(predicates, comicimg.HeightLTE(*i.HeightLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, comicimg.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, comicimg.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, comicimg.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, comicimg.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, comicimg.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, comicimg.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, comicimg.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, comicimg.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, comicimg.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, comicimg.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, comicimg.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, comicimg.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, comicimg.NameContainsFold(*i.NameContainsFold))
	}
	if i.OptimizedSize != nil {
		predicates = append(predicates, comicimg.OptimizedSizeEQ(*i.OptimizedSize))
	}
	if i.OptimizedSizeNEQ != nil {
		predicates = append(predicates, comicimg.OptimizedSizeNEQ(*i.OptimizedSizeNEQ))
	}
	if len(i.OptimizedSizeIn) > 0 {
		predicates = append(predicates, comicimg.OptimizedSizeIn(i.OptimizedSizeIn...))
	}
	if len(i.OptimizedSizeNotIn) > 0 {
		predicates = append(predicates, comicimg.OptimizedSizeNotIn(i.OptimizedSizeNotIn...))
	}
	if i.OptimizedSizeGT != nil {
		predicates = append(predicates, comicimg.OptimizedSizeGT(*i.OptimizedSizeGT))
	}
	if i.OptimizedSizeGTE != nil {
		predicates = append(predicates, comicimg.OptimizedSizeGTE(*i.OptimizedSizeGTE))
	}
	if i.OptimizedSizeLT != nil {
		predicates = append(predicates, comicimg.OptimizedSizeLT(*i.OptimizedSizeLT))
	}
	if i.OptimizedSizeLTE != nil {
		predicates = append(predicates, comicimg.OptimizedSizeLTE(*i.OptimizedSizeLTE))
	}
	if i.Size != nil {
		predicates = append(predicates, comicimg.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, comicimg.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, comicimg.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, comicimg.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, comicimg.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, comicimg.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, comicimg.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, comicimg.SizeLTE(*i.SizeLTE))
	}
	if i.Width != nil {
		predicates = append(predicates, comicimg.WidthEQ(*i.Width))
	}
	if i.WidthNEQ != nil {
		predicates = append(predicates, comicimg.WidthNEQ(*i.WidthNEQ))
	}
	if len(i.WidthIn) > 0 {
		predicates = append(predicates, comicimg.WidthIn(i.WidthIn...))
	}
	if len(i.WidthNotIn) > 0 {
		predicates = append(predicates, comicimg.WidthNotIn(i.WidthNotIn...))
	}
	if i.WidthGT != nil {
		predicates = append(predicates, comicimg.WidthGT(*i.WidthGT))
	}
	if i.WidthGTE != nil {
		predicates = append(predicates, comicimg.WidthGTE(*i.WidthGTE))
	}
	if i.WidthLT != nil {
		predicates = append(predicates, comicimg.WidthLT(*i.WidthLT))
	}
	if i.WidthLTE != nil {
		predicates = append(predicates, comicimg.WidthLTE(*i.WidthLTE))
	}

	if i.HasChapter != nil {
		p := comicimg.HasChapter()
		if !*i.HasChapter {
			p = comicimg.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChapterWith) > 0 {
		with := make([]predicate.ComicChapter, 0, len(i.HasChapterWith))
		for _, w := range i.HasChapterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChapterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comicimg.HasChapterWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyComicImgWhereInput
	case 1:
		return predicates[0], nil
	default:
		return comicimg.And(predicates...), nil
	}
}

// GenreWhereInput represents a where input for filtering Genre queries.
type GenreWhereInput struct {
	Predicates []predicate.Genre  `json:"-"`
	Not        *GenreWhereInput   `json:"not,omitempty"`
	Or         []*GenreWhereInput `json:"or,omitempty"`
	And        []*GenreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "type" field predicates.
	Type      *genre.Type  `json:"type,omitempty"`
	TypeNEQ   *genre.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []genre.Type `json:"typeIn,omitempty"`
	TypeNotIn []genre.Type `json:"typeNotIn,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GenreWhereInput) AddPredicates(predicates ...predicate.Genre) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GenreWhereInput filter on the GenreQuery builder.
func (i *GenreWhereInput) Filter(q *GenreQuery) (*GenreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGenreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGenreWhereInput is returned in case the GenreWhereInput is empty.
var ErrEmptyGenreWhereInput = errors.New("ent: empty predicate GenreWhereInput")

// P returns a predicate for filtering genres.
// An error is returned if the input is empty or invalid.
func (i *GenreWhereInput) P() (predicate.Genre, error) {
	var predicates []predicate.Genre
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, genre.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Genre, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, genre.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Genre, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, genre.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, genre.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, genre.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, genre.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, genre.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, genre.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, genre.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, genre.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, genre.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, genre.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, genre.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, genre.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, genre.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, genre.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, genre.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, genre.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, genre.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, genre.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, genre.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, genre.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, genre.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, genre.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, genre.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, genre.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, genre.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, genre.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, genre.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, genre.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, genre.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, genre.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, genre.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, genre.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, genre.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, genre.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, genre.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, genre.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, genre.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, genre.NameContainsFold(*i.NameContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, genre.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, genre.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, genre.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, genre.TypeNotIn(i.TypeNotIn...))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGenreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return genre.And(predicates...), nil
	}
}

// PermissionWhereInput represents a where input for filtering Permission queries.
type PermissionWhereInput struct {
	Predicates []predicate.Permission  `json:"-"`
	Not        *PermissionWhereInput   `json:"not,omitempty"`
	Or         []*PermissionWhereInput `json:"or,omitempty"`
	And        []*PermissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "group" field predicates.
	Group             *string  `json:"group,omitempty"`
	GroupNEQ          *string  `json:"groupNEQ,omitempty"`
	GroupIn           []string `json:"groupIn,omitempty"`
	GroupNotIn        []string `json:"groupNotIn,omitempty"`
	GroupGT           *string  `json:"groupGT,omitempty"`
	GroupGTE          *string  `json:"groupGTE,omitempty"`
	GroupLT           *string  `json:"groupLT,omitempty"`
	GroupLTE          *string  `json:"groupLTE,omitempty"`
	GroupContains     *string  `json:"groupContains,omitempty"`
	GroupHasPrefix    *string  `json:"groupHasPrefix,omitempty"`
	GroupHasSuffix    *string  `json:"groupHasSuffix,omitempty"`
	GroupEqualFold    *string  `json:"groupEqualFold,omitempty"`
	GroupContainsFold *string  `json:"groupContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PermissionWhereInput) AddPredicates(predicates ...predicate.Permission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PermissionWhereInput filter on the PermissionQuery builder.
func (i *PermissionWhereInput) Filter(q *PermissionQuery) (*PermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPermissionWhereInput is returned in case the PermissionWhereInput is empty.
var ErrEmptyPermissionWhereInput = errors.New("ent: empty predicate PermissionWhereInput")

// P returns a predicate for filtering permissions.
// An error is returned if the input is empty or invalid.
func (i *PermissionWhereInput) P() (predicate.Permission, error) {
	var predicates []predicate.Permission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, permission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Permission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, permission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Permission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, permission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, permission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, permission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, permission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, permission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, permission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, permission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, permission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, permission.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, permission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, permission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, permission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, permission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, permission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, permission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, permission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, permission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, permission.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, permission.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, permission.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, permission.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, permission.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, permission.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Group != nil {
		predicates = append(predicates, permission.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, permission.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, permission.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, permission.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, permission.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, permission.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, permission.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, permission.GroupLTE(*i.GroupLTE))
	}
	if i.GroupContains != nil {
		predicates = append(predicates, permission.GroupContains(*i.GroupContains))
	}
	if i.GroupHasPrefix != nil {
		predicates = append(predicates, permission.GroupHasPrefix(*i.GroupHasPrefix))
	}
	if i.GroupHasSuffix != nil {
		predicates = append(predicates, permission.GroupHasSuffix(*i.GroupHasSuffix))
	}
	if i.GroupEqualFold != nil {
		predicates = append(predicates, permission.GroupEqualFold(*i.GroupEqualFold))
	}
	if i.GroupContainsFold != nil {
		predicates = append(predicates, permission.GroupContainsFold(*i.GroupContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, permission.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, permission.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, permission.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, permission.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, permission.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, permission.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, permission.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, permission.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, permission.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, permission.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, permission.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, permission.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, permission.NameContainsFold(*i.NameContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, permission.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, permission.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, permission.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, permission.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, permission.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, permission.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, permission.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, permission.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, permission.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, permission.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, permission.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, permission.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, permission.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, permission.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, permission.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, permission.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, permission.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, permission.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, permission.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, permission.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, permission.OrderLTE(*i.OrderLTE))
	}

	if i.HasRoles != nil {
		p := permission.HasRoles()
		if !*i.HasRoles {
			p = permission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, permission.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return permission.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "is_changeable" field predicates.
	IsChangeable    *bool `json:"isChangeable,omitempty"`
	IsChangeableNEQ *bool `json:"isChangeableNEQ,omitempty"`

	// "admins" edge predicates.
	HasAdmins     *bool              `json:"hasAdmins,omitempty"`
	HasAdminsWith []*AdminWhereInput `json:"hasAdminsWith,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`

	// "routes" edge predicates.
	HasRoutes     *bool              `json:"hasRoutes,omitempty"`
	HasRoutesWith []*RouteWhereInput `json:"hasRoutesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, role.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, role.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, role.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, role.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, role.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, role.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, role.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, role.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, role.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, role.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, role.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, role.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, role.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, role.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, role.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, role.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, role.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, role.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, role.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, role.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, role.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, role.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, role.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, role.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, role.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, role.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, role.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, role.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, role.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, role.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, role.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, role.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, role.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, role.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, role.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, role.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, role.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, role.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, role.OrderLTE(*i.OrderLTE))
	}
	if i.IsChangeable != nil {
		predicates = append(predicates, role.IsChangeableEQ(*i.IsChangeable))
	}
	if i.IsChangeableNEQ != nil {
		predicates = append(predicates, role.IsChangeableNEQ(*i.IsChangeableNEQ))
	}

	if i.HasAdmins != nil {
		p := role.HasAdmins()
		if !*i.HasAdmins {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAdminsWith) > 0 {
		with := make([]predicate.Admin, 0, len(i.HasAdminsWith))
		for _, w := range i.HasAdminsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAdminsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasAdminsWith(with...))
	}
	if i.HasPermissions != nil {
		p := role.HasPermissions()
		if !*i.HasPermissions {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasPermissionsWith(with...))
	}
	if i.HasRoutes != nil {
		p := role.HasRoutes()
		if !*i.HasRoutes {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutesWith) > 0 {
		with := make([]predicate.Route, 0, len(i.HasRoutesWith))
		for _, w := range i.HasRoutesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasRoutesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}

// RouteWhereInput represents a where input for filtering Route queries.
type RouteWhereInput struct {
	Predicates []predicate.Route  `json:"-"`
	Not        *RouteWhereInput   `json:"not,omitempty"`
	Or         []*RouteWhereInput `json:"or,omitempty"`
	And        []*RouteWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "parent_id" field predicates.
	ParentID             *pulid.ID  `json:"parentID,omitempty"`
	ParentIDNEQ          *pulid.ID  `json:"parentIDNEQ,omitempty"`
	ParentIDIn           []pulid.ID `json:"parentIDIn,omitempty"`
	ParentIDNotIn        []pulid.ID `json:"parentIDNotIn,omitempty"`
	ParentIDGT           *pulid.ID  `json:"parentIDGT,omitempty"`
	ParentIDGTE          *pulid.ID  `json:"parentIDGTE,omitempty"`
	ParentIDLT           *pulid.ID  `json:"parentIDLT,omitempty"`
	ParentIDLTE          *pulid.ID  `json:"parentIDLTE,omitempty"`
	ParentIDContains     *pulid.ID  `json:"parentIDContains,omitempty"`
	ParentIDHasPrefix    *pulid.ID  `json:"parentIDHasPrefix,omitempty"`
	ParentIDHasSuffix    *pulid.ID  `json:"parentIDHasSuffix,omitempty"`
	ParentIDIsNil        bool       `json:"parentIDIsNil,omitempty"`
	ParentIDNotNil       bool       `json:"parentIDNotNil,omitempty"`
	ParentIDEqualFold    *pulid.ID  `json:"parentIDEqualFold,omitempty"`
	ParentIDContainsFold *pulid.ID  `json:"parentIDContainsFold,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "component" field predicates.
	Component             *string  `json:"component,omitempty"`
	ComponentNEQ          *string  `json:"componentNEQ,omitempty"`
	ComponentIn           []string `json:"componentIn,omitempty"`
	ComponentNotIn        []string `json:"componentNotIn,omitempty"`
	ComponentGT           *string  `json:"componentGT,omitempty"`
	ComponentGTE          *string  `json:"componentGTE,omitempty"`
	ComponentLT           *string  `json:"componentLT,omitempty"`
	ComponentLTE          *string  `json:"componentLTE,omitempty"`
	ComponentContains     *string  `json:"componentContains,omitempty"`
	ComponentHasPrefix    *string  `json:"componentHasPrefix,omitempty"`
	ComponentHasSuffix    *string  `json:"componentHasSuffix,omitempty"`
	ComponentEqualFold    *string  `json:"componentEqualFold,omitempty"`
	ComponentContainsFold *string  `json:"componentContainsFold,omitempty"`

	// "redirect" field predicates.
	Redirect             *string  `json:"redirect,omitempty"`
	RedirectNEQ          *string  `json:"redirectNEQ,omitempty"`
	RedirectIn           []string `json:"redirectIn,omitempty"`
	RedirectNotIn        []string `json:"redirectNotIn,omitempty"`
	RedirectGT           *string  `json:"redirectGT,omitempty"`
	RedirectGTE          *string  `json:"redirectGTE,omitempty"`
	RedirectLT           *string  `json:"redirectLT,omitempty"`
	RedirectLTE          *string  `json:"redirectLTE,omitempty"`
	RedirectContains     *string  `json:"redirectContains,omitempty"`
	RedirectHasPrefix    *string  `json:"redirectHasPrefix,omitempty"`
	RedirectHasSuffix    *string  `json:"redirectHasSuffix,omitempty"`
	RedirectIsNil        bool     `json:"redirectIsNil,omitempty"`
	RedirectNotNil       bool     `json:"redirectNotNil,omitempty"`
	RedirectEqualFold    *string  `json:"redirectEqualFold,omitempty"`
	RedirectContainsFold *string  `json:"redirectContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "order" field predicates.
	Order       *int  `json:"order,omitempty"`
	OrderNEQ    *int  `json:"orderNEQ,omitempty"`
	OrderIn     []int `json:"orderIn,omitempty"`
	OrderNotIn  []int `json:"orderNotIn,omitempty"`
	OrderGT     *int  `json:"orderGT,omitempty"`
	OrderGTE    *int  `json:"orderGTE,omitempty"`
	OrderLT     *int  `json:"orderLT,omitempty"`
	OrderLTE    *int  `json:"orderLTE,omitempty"`
	OrderIsNil  bool  `json:"orderIsNil,omitempty"`
	OrderNotNil bool  `json:"orderNotNil,omitempty"`

	// "type" field predicates.
	Type      *route.Type  `json:"type,omitempty"`
	TypeNEQ   *route.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []route.Type `json:"typeIn,omitempty"`
	TypeNotIn []route.Type `json:"typeNotIn,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool              `json:"hasParent,omitempty"`
	HasParentWith []*RouteWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool              `json:"hasChildren,omitempty"`
	HasChildrenWith []*RouteWhereInput `json:"hasChildrenWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RouteWhereInput) AddPredicates(predicates ...predicate.Route) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RouteWhereInput filter on the RouteQuery builder.
func (i *RouteWhereInput) Filter(q *RouteQuery) (*RouteQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRouteWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRouteWhereInput is returned in case the RouteWhereInput is empty.
var ErrEmptyRouteWhereInput = errors.New("ent: empty predicate RouteWhereInput")

// P returns a predicate for filtering routes.
// An error is returned if the input is empty or invalid.
func (i *RouteWhereInput) P() (predicate.Route, error) {
	var predicates []predicate.Route
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, route.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Route, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, route.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Route, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, route.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, route.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, route.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, route.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, route.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, route.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, route.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, route.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, route.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, route.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, route.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, route.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, route.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, route.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, route.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, route.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, route.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, route.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, route.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, route.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, route.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, route.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, route.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, route.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, route.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, route.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, route.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, route.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, route.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, route.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, route.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, route.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, route.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, route.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, route.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.ParentID != nil {
		predicates = append(predicates, route.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, route.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, route.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, route.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.ParentIDGT != nil {
		predicates = append(predicates, route.ParentIDGT(*i.ParentIDGT))
	}
	if i.ParentIDGTE != nil {
		predicates = append(predicates, route.ParentIDGTE(*i.ParentIDGTE))
	}
	if i.ParentIDLT != nil {
		predicates = append(predicates, route.ParentIDLT(*i.ParentIDLT))
	}
	if i.ParentIDLTE != nil {
		predicates = append(predicates, route.ParentIDLTE(*i.ParentIDLTE))
	}
	if i.ParentIDContains != nil {
		predicates = append(predicates, route.ParentIDContains(*i.ParentIDContains))
	}
	if i.ParentIDHasPrefix != nil {
		predicates = append(predicates, route.ParentIDHasPrefix(*i.ParentIDHasPrefix))
	}
	if i.ParentIDHasSuffix != nil {
		predicates = append(predicates, route.ParentIDHasSuffix(*i.ParentIDHasSuffix))
	}
	if i.ParentIDIsNil {
		predicates = append(predicates, route.ParentIDIsNil())
	}
	if i.ParentIDNotNil {
		predicates = append(predicates, route.ParentIDNotNil())
	}
	if i.ParentIDEqualFold != nil {
		predicates = append(predicates, route.ParentIDEqualFold(*i.ParentIDEqualFold))
	}
	if i.ParentIDContainsFold != nil {
		predicates = append(predicates, route.ParentIDContainsFold(*i.ParentIDContainsFold))
	}
	if i.Path != nil {
		predicates = append(predicates, route.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, route.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, route.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, route.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, route.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, route.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, route.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, route.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, route.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, route.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, route.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, route.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, route.PathContainsFold(*i.PathContainsFold))
	}
	if i.Component != nil {
		predicates = append(predicates, route.ComponentEQ(*i.Component))
	}
	if i.ComponentNEQ != nil {
		predicates = append(predicates, route.ComponentNEQ(*i.ComponentNEQ))
	}
	if len(i.ComponentIn) > 0 {
		predicates = append(predicates, route.ComponentIn(i.ComponentIn...))
	}
	if len(i.ComponentNotIn) > 0 {
		predicates = append(predicates, route.ComponentNotIn(i.ComponentNotIn...))
	}
	if i.ComponentGT != nil {
		predicates = append(predicates, route.ComponentGT(*i.ComponentGT))
	}
	if i.ComponentGTE != nil {
		predicates = append(predicates, route.ComponentGTE(*i.ComponentGTE))
	}
	if i.ComponentLT != nil {
		predicates = append(predicates, route.ComponentLT(*i.ComponentLT))
	}
	if i.ComponentLTE != nil {
		predicates = append(predicates, route.ComponentLTE(*i.ComponentLTE))
	}
	if i.ComponentContains != nil {
		predicates = append(predicates, route.ComponentContains(*i.ComponentContains))
	}
	if i.ComponentHasPrefix != nil {
		predicates = append(predicates, route.ComponentHasPrefix(*i.ComponentHasPrefix))
	}
	if i.ComponentHasSuffix != nil {
		predicates = append(predicates, route.ComponentHasSuffix(*i.ComponentHasSuffix))
	}
	if i.ComponentEqualFold != nil {
		predicates = append(predicates, route.ComponentEqualFold(*i.ComponentEqualFold))
	}
	if i.ComponentContainsFold != nil {
		predicates = append(predicates, route.ComponentContainsFold(*i.ComponentContainsFold))
	}
	if i.Redirect != nil {
		predicates = append(predicates, route.RedirectEQ(*i.Redirect))
	}
	if i.RedirectNEQ != nil {
		predicates = append(predicates, route.RedirectNEQ(*i.RedirectNEQ))
	}
	if len(i.RedirectIn) > 0 {
		predicates = append(predicates, route.RedirectIn(i.RedirectIn...))
	}
	if len(i.RedirectNotIn) > 0 {
		predicates = append(predicates, route.RedirectNotIn(i.RedirectNotIn...))
	}
	if i.RedirectGT != nil {
		predicates = append(predicates, route.RedirectGT(*i.RedirectGT))
	}
	if i.RedirectGTE != nil {
		predicates = append(predicates, route.RedirectGTE(*i.RedirectGTE))
	}
	if i.RedirectLT != nil {
		predicates = append(predicates, route.RedirectLT(*i.RedirectLT))
	}
	if i.RedirectLTE != nil {
		predicates = append(predicates, route.RedirectLTE(*i.RedirectLTE))
	}
	if i.RedirectContains != nil {
		predicates = append(predicates, route.RedirectContains(*i.RedirectContains))
	}
	if i.RedirectHasPrefix != nil {
		predicates = append(predicates, route.RedirectHasPrefix(*i.RedirectHasPrefix))
	}
	if i.RedirectHasSuffix != nil {
		predicates = append(predicates, route.RedirectHasSuffix(*i.RedirectHasSuffix))
	}
	if i.RedirectIsNil {
		predicates = append(predicates, route.RedirectIsNil())
	}
	if i.RedirectNotNil {
		predicates = append(predicates, route.RedirectNotNil())
	}
	if i.RedirectEqualFold != nil {
		predicates = append(predicates, route.RedirectEqualFold(*i.RedirectEqualFold))
	}
	if i.RedirectContainsFold != nil {
		predicates = append(predicates, route.RedirectContainsFold(*i.RedirectContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, route.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, route.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, route.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, route.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, route.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, route.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, route.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, route.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, route.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, route.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, route.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, route.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, route.NameContainsFold(*i.NameContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, route.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, route.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, route.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, route.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, route.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, route.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, route.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, route.OrderLTE(*i.OrderLTE))
	}
	if i.OrderIsNil {
		predicates = append(predicates, route.OrderIsNil())
	}
	if i.OrderNotNil {
		predicates = append(predicates, route.OrderNotNil())
	}
	if i.Type != nil {
		predicates = append(predicates, route.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, route.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, route.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, route.TypeNotIn(i.TypeNotIn...))
	}

	if i.HasParent != nil {
		p := route.HasParent()
		if !*i.HasParent {
			p = route.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Route, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, route.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := route.HasChildren()
		if !*i.HasChildren {
			p = route.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Route, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, route.HasChildrenWith(with...))
	}
	if i.HasRoles != nil {
		p := route.HasRoles()
		if !*i.HasRoles {
			p = route.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, route.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRouteWhereInput
	case 1:
		return predicates[0], nil
	default:
		return route.And(predicates...), nil
	}
}
