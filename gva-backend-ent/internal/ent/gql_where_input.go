// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/gva/app/database/schema/pxid"
	"github.com/gva/internal/ent/admin"
	"github.com/gva/internal/ent/department"
	"github.com/gva/internal/ent/genre"
	"github.com/gva/internal/ent/manga"
	"github.com/gva/internal/ent/mangachapter"
	"github.com/gva/internal/ent/permission"
	"github.com/gva/internal/ent/predicate"
	"github.com/gva/internal/ent/role"
)

// AdminWhereInput represents a where input for filtering Admin queries.
type AdminWhereInput struct {
	Predicates []predicate.Admin  `json:"-"`
	Not        *AdminWhereInput   `json:"not,omitempty"`
	Or         []*AdminWhereInput `json:"or,omitempty"`
	And        []*AdminWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pxid.ID  `json:"id,omitempty"`
	IDNEQ   *pxid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pxid.ID `json:"idIn,omitempty"`
	IDNotIn []pxid.ID `json:"idNotIn,omitempty"`
	IDGT    *pxid.ID  `json:"idGT,omitempty"`
	IDGTE   *pxid.ID  `json:"idGTE,omitempty"`
	IDLT    *pxid.ID  `json:"idLT,omitempty"`
	IDLTE   *pxid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "department_id" field predicates.
	DepartmentID             *pxid.ID  `json:"departmentID,omitempty"`
	DepartmentIDNEQ          *pxid.ID  `json:"departmentIDNEQ,omitempty"`
	DepartmentIDIn           []pxid.ID `json:"departmentIDIn,omitempty"`
	DepartmentIDNotIn        []pxid.ID `json:"departmentIDNotIn,omitempty"`
	DepartmentIDGT           *pxid.ID  `json:"departmentIDGT,omitempty"`
	DepartmentIDGTE          *pxid.ID  `json:"departmentIDGTE,omitempty"`
	DepartmentIDLT           *pxid.ID  `json:"departmentIDLT,omitempty"`
	DepartmentIDLTE          *pxid.ID  `json:"departmentIDLTE,omitempty"`
	DepartmentIDContains     *pxid.ID  `json:"departmentIDContains,omitempty"`
	DepartmentIDHasPrefix    *pxid.ID  `json:"departmentIDHasPrefix,omitempty"`
	DepartmentIDHasSuffix    *pxid.ID  `json:"departmentIDHasSuffix,omitempty"`
	DepartmentIDIsNil        bool      `json:"departmentIDIsNil,omitempty"`
	DepartmentIDNotNil       bool      `json:"departmentIDNotNil,omitempty"`
	DepartmentIDEqualFold    *pxid.ID  `json:"departmentIDEqualFold,omitempty"`
	DepartmentIDContainsFold *pxid.ID  `json:"departmentIDContainsFold,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`

	// "department" edge predicates.
	HasDepartment     *bool                   `json:"hasDepartment,omitempty"`
	HasDepartmentWith []*DepartmentWhereInput `json:"hasDepartmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AdminWhereInput) AddPredicates(predicates ...predicate.Admin) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AdminWhereInput filter on the AdminQuery builder.
func (i *AdminWhereInput) Filter(q *AdminQuery) (*AdminQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAdminWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAdminWhereInput is returned in case the AdminWhereInput is empty.
var ErrEmptyAdminWhereInput = errors.New("ent: empty predicate AdminWhereInput")

// P returns a predicate for filtering admins.
// An error is returned if the input is empty or invalid.
func (i *AdminWhereInput) P() (predicate.Admin, error) {
	var predicates []predicate.Admin
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, admin.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Admin, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, admin.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Admin, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, admin.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, admin.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, admin.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, admin.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, admin.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, admin.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, admin.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, admin.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, admin.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, admin.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, admin.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, admin.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, admin.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, admin.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, admin.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, admin.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, admin.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, admin.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, admin.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, admin.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, admin.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, admin.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, admin.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, admin.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, admin.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, admin.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, admin.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, admin.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, admin.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, admin.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, admin.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, admin.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, admin.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, admin.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, admin.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, admin.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, admin.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, admin.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, admin.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, admin.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, admin.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, admin.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, admin.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, admin.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, admin.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, admin.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, admin.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, admin.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, admin.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, admin.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, admin.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, admin.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, admin.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, admin.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, admin.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, admin.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, admin.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, admin.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, admin.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, admin.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, admin.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, admin.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, admin.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, admin.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, admin.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, admin.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, admin.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, admin.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, admin.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, admin.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, admin.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, admin.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, admin.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, admin.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, admin.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, admin.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.DepartmentID != nil {
		predicates = append(predicates, admin.DepartmentIDEQ(*i.DepartmentID))
	}
	if i.DepartmentIDNEQ != nil {
		predicates = append(predicates, admin.DepartmentIDNEQ(*i.DepartmentIDNEQ))
	}
	if len(i.DepartmentIDIn) > 0 {
		predicates = append(predicates, admin.DepartmentIDIn(i.DepartmentIDIn...))
	}
	if len(i.DepartmentIDNotIn) > 0 {
		predicates = append(predicates, admin.DepartmentIDNotIn(i.DepartmentIDNotIn...))
	}
	if i.DepartmentIDGT != nil {
		predicates = append(predicates, admin.DepartmentIDGT(*i.DepartmentIDGT))
	}
	if i.DepartmentIDGTE != nil {
		predicates = append(predicates, admin.DepartmentIDGTE(*i.DepartmentIDGTE))
	}
	if i.DepartmentIDLT != nil {
		predicates = append(predicates, admin.DepartmentIDLT(*i.DepartmentIDLT))
	}
	if i.DepartmentIDLTE != nil {
		predicates = append(predicates, admin.DepartmentIDLTE(*i.DepartmentIDLTE))
	}
	if i.DepartmentIDContains != nil {
		predicates = append(predicates, admin.DepartmentIDContains(*i.DepartmentIDContains))
	}
	if i.DepartmentIDHasPrefix != nil {
		predicates = append(predicates, admin.DepartmentIDHasPrefix(*i.DepartmentIDHasPrefix))
	}
	if i.DepartmentIDHasSuffix != nil {
		predicates = append(predicates, admin.DepartmentIDHasSuffix(*i.DepartmentIDHasSuffix))
	}
	if i.DepartmentIDIsNil {
		predicates = append(predicates, admin.DepartmentIDIsNil())
	}
	if i.DepartmentIDNotNil {
		predicates = append(predicates, admin.DepartmentIDNotNil())
	}
	if i.DepartmentIDEqualFold != nil {
		predicates = append(predicates, admin.DepartmentIDEqualFold(*i.DepartmentIDEqualFold))
	}
	if i.DepartmentIDContainsFold != nil {
		predicates = append(predicates, admin.DepartmentIDContainsFold(*i.DepartmentIDContainsFold))
	}

	if i.HasRoles != nil {
		p := admin.HasRoles()
		if !*i.HasRoles {
			p = admin.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, admin.HasRolesWith(with...))
	}
	if i.HasDepartment != nil {
		p := admin.HasDepartment()
		if !*i.HasDepartment {
			p = admin.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDepartmentWith) > 0 {
		with := make([]predicate.Department, 0, len(i.HasDepartmentWith))
		for _, w := range i.HasDepartmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDepartmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, admin.HasDepartmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAdminWhereInput
	case 1:
		return predicates[0], nil
	default:
		return admin.And(predicates...), nil
	}
}

// DepartmentWhereInput represents a where input for filtering Department queries.
type DepartmentWhereInput struct {
	Predicates []predicate.Department  `json:"-"`
	Not        *DepartmentWhereInput   `json:"not,omitempty"`
	Or         []*DepartmentWhereInput `json:"or,omitempty"`
	And        []*DepartmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pxid.ID  `json:"id,omitempty"`
	IDNEQ   *pxid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pxid.ID `json:"idIn,omitempty"`
	IDNotIn []pxid.ID `json:"idNotIn,omitempty"`
	IDGT    *pxid.ID  `json:"idGT,omitempty"`
	IDGTE   *pxid.ID  `json:"idGTE,omitempty"`
	IDLT    *pxid.ID  `json:"idLT,omitempty"`
	IDLTE   *pxid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "name_id" field predicates.
	NameID             *string  `json:"nameID,omitempty"`
	NameIDNEQ          *string  `json:"nameIDNEQ,omitempty"`
	NameIDIn           []string `json:"nameIDIn,omitempty"`
	NameIDNotIn        []string `json:"nameIDNotIn,omitempty"`
	NameIDGT           *string  `json:"nameIDGT,omitempty"`
	NameIDGTE          *string  `json:"nameIDGTE,omitempty"`
	NameIDLT           *string  `json:"nameIDLT,omitempty"`
	NameIDLTE          *string  `json:"nameIDLTE,omitempty"`
	NameIDContains     *string  `json:"nameIDContains,omitempty"`
	NameIDHasPrefix    *string  `json:"nameIDHasPrefix,omitempty"`
	NameIDHasSuffix    *string  `json:"nameIDHasSuffix,omitempty"`
	NameIDEqualFold    *string  `json:"nameIDEqualFold,omitempty"`
	NameIDContainsFold *string  `json:"nameIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "pid" field predicates.
	Pid             *pxid.ID  `json:"pid,omitempty"`
	PidNEQ          *pxid.ID  `json:"pidNEQ,omitempty"`
	PidIn           []pxid.ID `json:"pidIn,omitempty"`
	PidNotIn        []pxid.ID `json:"pidNotIn,omitempty"`
	PidGT           *pxid.ID  `json:"pidGT,omitempty"`
	PidGTE          *pxid.ID  `json:"pidGTE,omitempty"`
	PidLT           *pxid.ID  `json:"pidLT,omitempty"`
	PidLTE          *pxid.ID  `json:"pidLTE,omitempty"`
	PidContains     *pxid.ID  `json:"pidContains,omitempty"`
	PidHasPrefix    *pxid.ID  `json:"pidHasPrefix,omitempty"`
	PidHasSuffix    *pxid.ID  `json:"pidHasSuffix,omitempty"`
	PidIsNil        bool      `json:"pidIsNil,omitempty"`
	PidNotNil       bool      `json:"pidNotNil,omitempty"`
	PidEqualFold    *pxid.ID  `json:"pidEqualFold,omitempty"`
	PidContainsFold *pxid.ID  `json:"pidContainsFold,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool                   `json:"hasParent,omitempty"`
	HasParentWith []*DepartmentWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool                   `json:"hasChildren,omitempty"`
	HasChildrenWith []*DepartmentWhereInput `json:"hasChildrenWith,omitempty"`

	// "members" edge predicates.
	HasMembers     *bool              `json:"hasMembers,omitempty"`
	HasMembersWith []*AdminWhereInput `json:"hasMembersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DepartmentWhereInput) AddPredicates(predicates ...predicate.Department) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DepartmentWhereInput filter on the DepartmentQuery builder.
func (i *DepartmentWhereInput) Filter(q *DepartmentQuery) (*DepartmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDepartmentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDepartmentWhereInput is returned in case the DepartmentWhereInput is empty.
var ErrEmptyDepartmentWhereInput = errors.New("ent: empty predicate DepartmentWhereInput")

// P returns a predicate for filtering departments.
// An error is returned if the input is empty or invalid.
func (i *DepartmentWhereInput) P() (predicate.Department, error) {
	var predicates []predicate.Department
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, department.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Department, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, department.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Department, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, department.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, department.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, department.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, department.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, department.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, department.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, department.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, department.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, department.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, department.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, department.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, department.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, department.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, department.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, department.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, department.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, department.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, department.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, department.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, department.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, department.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, department.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, department.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, department.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, department.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, department.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, department.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, department.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, department.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, department.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, department.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, department.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, department.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, department.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, department.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.NameID != nil {
		predicates = append(predicates, department.NameIDEQ(*i.NameID))
	}
	if i.NameIDNEQ != nil {
		predicates = append(predicates, department.NameIDNEQ(*i.NameIDNEQ))
	}
	if len(i.NameIDIn) > 0 {
		predicates = append(predicates, department.NameIDIn(i.NameIDIn...))
	}
	if len(i.NameIDNotIn) > 0 {
		predicates = append(predicates, department.NameIDNotIn(i.NameIDNotIn...))
	}
	if i.NameIDGT != nil {
		predicates = append(predicates, department.NameIDGT(*i.NameIDGT))
	}
	if i.NameIDGTE != nil {
		predicates = append(predicates, department.NameIDGTE(*i.NameIDGTE))
	}
	if i.NameIDLT != nil {
		predicates = append(predicates, department.NameIDLT(*i.NameIDLT))
	}
	if i.NameIDLTE != nil {
		predicates = append(predicates, department.NameIDLTE(*i.NameIDLTE))
	}
	if i.NameIDContains != nil {
		predicates = append(predicates, department.NameIDContains(*i.NameIDContains))
	}
	if i.NameIDHasPrefix != nil {
		predicates = append(predicates, department.NameIDHasPrefix(*i.NameIDHasPrefix))
	}
	if i.NameIDHasSuffix != nil {
		predicates = append(predicates, department.NameIDHasSuffix(*i.NameIDHasSuffix))
	}
	if i.NameIDEqualFold != nil {
		predicates = append(predicates, department.NameIDEqualFold(*i.NameIDEqualFold))
	}
	if i.NameIDContainsFold != nil {
		predicates = append(predicates, department.NameIDContainsFold(*i.NameIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, department.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, department.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, department.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, department.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, department.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, department.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, department.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, department.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, department.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, department.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, department.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, department.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, department.NameContainsFold(*i.NameContainsFold))
	}
	if i.Pid != nil {
		predicates = append(predicates, department.PidEQ(*i.Pid))
	}
	if i.PidNEQ != nil {
		predicates = append(predicates, department.PidNEQ(*i.PidNEQ))
	}
	if len(i.PidIn) > 0 {
		predicates = append(predicates, department.PidIn(i.PidIn...))
	}
	if len(i.PidNotIn) > 0 {
		predicates = append(predicates, department.PidNotIn(i.PidNotIn...))
	}
	if i.PidGT != nil {
		predicates = append(predicates, department.PidGT(*i.PidGT))
	}
	if i.PidGTE != nil {
		predicates = append(predicates, department.PidGTE(*i.PidGTE))
	}
	if i.PidLT != nil {
		predicates = append(predicates, department.PidLT(*i.PidLT))
	}
	if i.PidLTE != nil {
		predicates = append(predicates, department.PidLTE(*i.PidLTE))
	}
	if i.PidContains != nil {
		predicates = append(predicates, department.PidContains(*i.PidContains))
	}
	if i.PidHasPrefix != nil {
		predicates = append(predicates, department.PidHasPrefix(*i.PidHasPrefix))
	}
	if i.PidHasSuffix != nil {
		predicates = append(predicates, department.PidHasSuffix(*i.PidHasSuffix))
	}
	if i.PidIsNil {
		predicates = append(predicates, department.PidIsNil())
	}
	if i.PidNotNil {
		predicates = append(predicates, department.PidNotNil())
	}
	if i.PidEqualFold != nil {
		predicates = append(predicates, department.PidEqualFold(*i.PidEqualFold))
	}
	if i.PidContainsFold != nil {
		predicates = append(predicates, department.PidContainsFold(*i.PidContainsFold))
	}

	if i.HasParent != nil {
		p := department.HasParent()
		if !*i.HasParent {
			p = department.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Department, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, department.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := department.HasChildren()
		if !*i.HasChildren {
			p = department.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Department, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, department.HasChildrenWith(with...))
	}
	if i.HasMembers != nil {
		p := department.HasMembers()
		if !*i.HasMembers {
			p = department.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMembersWith) > 0 {
		with := make([]predicate.Admin, 0, len(i.HasMembersWith))
		for _, w := range i.HasMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMembersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, department.HasMembersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDepartmentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return department.And(predicates...), nil
	}
}

// GenreWhereInput represents a where input for filtering Genre queries.
type GenreWhereInput struct {
	Predicates []predicate.Genre  `json:"-"`
	Not        *GenreWhereInput   `json:"not,omitempty"`
	Or         []*GenreWhereInput `json:"or,omitempty"`
	And        []*GenreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pxid.ID  `json:"id,omitempty"`
	IDNEQ   *pxid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pxid.ID `json:"idIn,omitempty"`
	IDNotIn []pxid.ID `json:"idNotIn,omitempty"`
	IDGT    *pxid.ID  `json:"idGT,omitempty"`
	IDGTE   *pxid.ID  `json:"idGTE,omitempty"`
	IDLT    *pxid.ID  `json:"idLT,omitempty"`
	IDLTE   *pxid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "name_id" field predicates.
	NameID             *string  `json:"nameID,omitempty"`
	NameIDNEQ          *string  `json:"nameIDNEQ,omitempty"`
	NameIDIn           []string `json:"nameIDIn,omitempty"`
	NameIDNotIn        []string `json:"nameIDNotIn,omitempty"`
	NameIDGT           *string  `json:"nameIDGT,omitempty"`
	NameIDGTE          *string  `json:"nameIDGTE,omitempty"`
	NameIDLT           *string  `json:"nameIDLT,omitempty"`
	NameIDLTE          *string  `json:"nameIDLTE,omitempty"`
	NameIDContains     *string  `json:"nameIDContains,omitempty"`
	NameIDHasPrefix    *string  `json:"nameIDHasPrefix,omitempty"`
	NameIDHasSuffix    *string  `json:"nameIDHasSuffix,omitempty"`
	NameIDEqualFold    *string  `json:"nameIDEqualFold,omitempty"`
	NameIDContainsFold *string  `json:"nameIDContainsFold,omitempty"`

	// "mangas" edge predicates.
	HasMangas     *bool              `json:"hasMangas,omitempty"`
	HasMangasWith []*MangaWhereInput `json:"hasMangasWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GenreWhereInput) AddPredicates(predicates ...predicate.Genre) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GenreWhereInput filter on the GenreQuery builder.
func (i *GenreWhereInput) Filter(q *GenreQuery) (*GenreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGenreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGenreWhereInput is returned in case the GenreWhereInput is empty.
var ErrEmptyGenreWhereInput = errors.New("ent: empty predicate GenreWhereInput")

// P returns a predicate for filtering genres.
// An error is returned if the input is empty or invalid.
func (i *GenreWhereInput) P() (predicate.Genre, error) {
	var predicates []predicate.Genre
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, genre.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Genre, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, genre.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Genre, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, genre.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, genre.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, genre.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, genre.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, genre.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, genre.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, genre.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, genre.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, genre.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, genre.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, genre.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, genre.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, genre.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, genre.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, genre.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, genre.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, genre.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, genre.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, genre.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, genre.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, genre.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, genre.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, genre.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, genre.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, genre.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, genre.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, genre.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, genre.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, genre.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, genre.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, genre.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, genre.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, genre.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, genre.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, genre.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, genre.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, genre.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, genre.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, genre.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, genre.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, genre.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, genre.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, genre.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, genre.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, genre.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, genre.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, genre.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, genre.NameContainsFold(*i.NameContainsFold))
	}
	if i.NameID != nil {
		predicates = append(predicates, genre.NameIDEQ(*i.NameID))
	}
	if i.NameIDNEQ != nil {
		predicates = append(predicates, genre.NameIDNEQ(*i.NameIDNEQ))
	}
	if len(i.NameIDIn) > 0 {
		predicates = append(predicates, genre.NameIDIn(i.NameIDIn...))
	}
	if len(i.NameIDNotIn) > 0 {
		predicates = append(predicates, genre.NameIDNotIn(i.NameIDNotIn...))
	}
	if i.NameIDGT != nil {
		predicates = append(predicates, genre.NameIDGT(*i.NameIDGT))
	}
	if i.NameIDGTE != nil {
		predicates = append(predicates, genre.NameIDGTE(*i.NameIDGTE))
	}
	if i.NameIDLT != nil {
		predicates = append(predicates, genre.NameIDLT(*i.NameIDLT))
	}
	if i.NameIDLTE != nil {
		predicates = append(predicates, genre.NameIDLTE(*i.NameIDLTE))
	}
	if i.NameIDContains != nil {
		predicates = append(predicates, genre.NameIDContains(*i.NameIDContains))
	}
	if i.NameIDHasPrefix != nil {
		predicates = append(predicates, genre.NameIDHasPrefix(*i.NameIDHasPrefix))
	}
	if i.NameIDHasSuffix != nil {
		predicates = append(predicates, genre.NameIDHasSuffix(*i.NameIDHasSuffix))
	}
	if i.NameIDEqualFold != nil {
		predicates = append(predicates, genre.NameIDEqualFold(*i.NameIDEqualFold))
	}
	if i.NameIDContainsFold != nil {
		predicates = append(predicates, genre.NameIDContainsFold(*i.NameIDContainsFold))
	}

	if i.HasMangas != nil {
		p := genre.HasMangas()
		if !*i.HasMangas {
			p = genre.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMangasWith) > 0 {
		with := make([]predicate.Manga, 0, len(i.HasMangasWith))
		for _, w := range i.HasMangasWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMangasWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, genre.HasMangasWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGenreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return genre.And(predicates...), nil
	}
}

// MangaWhereInput represents a where input for filtering Manga queries.
type MangaWhereInput struct {
	Predicates []predicate.Manga  `json:"-"`
	Not        *MangaWhereInput   `json:"not,omitempty"`
	Or         []*MangaWhereInput `json:"or,omitempty"`
	And        []*MangaWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pxid.ID  `json:"id,omitempty"`
	IDNEQ   *pxid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pxid.ID `json:"idIn,omitempty"`
	IDNotIn []pxid.ID `json:"idNotIn,omitempty"`
	IDGT    *pxid.ID  `json:"idGT,omitempty"`
	IDGTE   *pxid.ID  `json:"idGTE,omitempty"`
	IDLT    *pxid.ID  `json:"idLT,omitempty"`
	IDLTE   *pxid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name_id" field predicates.
	NameID             *string  `json:"nameID,omitempty"`
	NameIDNEQ          *string  `json:"nameIDNEQ,omitempty"`
	NameIDIn           []string `json:"nameIDIn,omitempty"`
	NameIDNotIn        []string `json:"nameIDNotIn,omitempty"`
	NameIDGT           *string  `json:"nameIDGT,omitempty"`
	NameIDGTE          *string  `json:"nameIDGTE,omitempty"`
	NameIDLT           *string  `json:"nameIDLT,omitempty"`
	NameIDLTE          *string  `json:"nameIDLTE,omitempty"`
	NameIDContains     *string  `json:"nameIDContains,omitempty"`
	NameIDHasPrefix    *string  `json:"nameIDHasPrefix,omitempty"`
	NameIDHasSuffix    *string  `json:"nameIDHasSuffix,omitempty"`
	NameIDEqualFold    *string  `json:"nameIDEqualFold,omitempty"`
	NameIDContainsFold *string  `json:"nameIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "desc" field predicates.
	Desc             *string  `json:"desc,omitempty"`
	DescNEQ          *string  `json:"descNEQ,omitempty"`
	DescIn           []string `json:"descIn,omitempty"`
	DescNotIn        []string `json:"descNotIn,omitempty"`
	DescGT           *string  `json:"descGT,omitempty"`
	DescGTE          *string  `json:"descGTE,omitempty"`
	DescLT           *string  `json:"descLT,omitempty"`
	DescLTE          *string  `json:"descLTE,omitempty"`
	DescContains     *string  `json:"descContains,omitempty"`
	DescHasPrefix    *string  `json:"descHasPrefix,omitempty"`
	DescHasSuffix    *string  `json:"descHasSuffix,omitempty"`
	DescEqualFold    *string  `json:"descEqualFold,omitempty"`
	DescContainsFold *string  `json:"descContainsFold,omitempty"`

	// "prodiver" field predicates.
	Prodiver             *string  `json:"prodiver,omitempty"`
	ProdiverNEQ          *string  `json:"prodiverNEQ,omitempty"`
	ProdiverIn           []string `json:"prodiverIn,omitempty"`
	ProdiverNotIn        []string `json:"prodiverNotIn,omitempty"`
	ProdiverGT           *string  `json:"prodiverGT,omitempty"`
	ProdiverGTE          *string  `json:"prodiverGTE,omitempty"`
	ProdiverLT           *string  `json:"prodiverLT,omitempty"`
	ProdiverLTE          *string  `json:"prodiverLTE,omitempty"`
	ProdiverContains     *string  `json:"prodiverContains,omitempty"`
	ProdiverHasPrefix    *string  `json:"prodiverHasPrefix,omitempty"`
	ProdiverHasSuffix    *string  `json:"prodiverHasSuffix,omitempty"`
	ProdiverEqualFold    *string  `json:"prodiverEqualFold,omitempty"`
	ProdiverContainsFold *string  `json:"prodiverContainsFold,omitempty"`

	// "thumbnail_url" field predicates.
	ThumbnailURL             *string  `json:"thumbnailURL,omitempty"`
	ThumbnailURLNEQ          *string  `json:"thumbnailURLNEQ,omitempty"`
	ThumbnailURLIn           []string `json:"thumbnailURLIn,omitempty"`
	ThumbnailURLNotIn        []string `json:"thumbnailURLNotIn,omitempty"`
	ThumbnailURLGT           *string  `json:"thumbnailURLGT,omitempty"`
	ThumbnailURLGTE          *string  `json:"thumbnailURLGTE,omitempty"`
	ThumbnailURLLT           *string  `json:"thumbnailURLLT,omitempty"`
	ThumbnailURLLTE          *string  `json:"thumbnailURLLTE,omitempty"`
	ThumbnailURLContains     *string  `json:"thumbnailURLContains,omitempty"`
	ThumbnailURLHasPrefix    *string  `json:"thumbnailURLHasPrefix,omitempty"`
	ThumbnailURLHasSuffix    *string  `json:"thumbnailURLHasSuffix,omitempty"`
	ThumbnailURLEqualFold    *string  `json:"thumbnailURLEqualFold,omitempty"`
	ThumbnailURLContainsFold *string  `json:"thumbnailURLContainsFold,omitempty"`

	// "chapters" edge predicates.
	HasChapters     *bool                     `json:"hasChapters,omitempty"`
	HasChaptersWith []*MangaChapterWhereInput `json:"hasChaptersWith,omitempty"`

	// "genres" edge predicates.
	HasGenres     *bool              `json:"hasGenres,omitempty"`
	HasGenresWith []*GenreWhereInput `json:"hasGenresWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MangaWhereInput) AddPredicates(predicates ...predicate.Manga) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MangaWhereInput filter on the MangaQuery builder.
func (i *MangaWhereInput) Filter(q *MangaQuery) (*MangaQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMangaWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMangaWhereInput is returned in case the MangaWhereInput is empty.
var ErrEmptyMangaWhereInput = errors.New("ent: empty predicate MangaWhereInput")

// P returns a predicate for filtering mangas.
// An error is returned if the input is empty or invalid.
func (i *MangaWhereInput) P() (predicate.Manga, error) {
	var predicates []predicate.Manga
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, manga.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Manga, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, manga.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Manga, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, manga.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, manga.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, manga.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, manga.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, manga.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, manga.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, manga.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, manga.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, manga.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, manga.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, manga.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, manga.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, manga.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, manga.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, manga.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, manga.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, manga.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, manga.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, manga.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, manga.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, manga.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, manga.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, manga.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, manga.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, manga.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, manga.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, manga.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, manga.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, manga.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, manga.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, manga.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, manga.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, manga.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, manga.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, manga.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.NameID != nil {
		predicates = append(predicates, manga.NameIDEQ(*i.NameID))
	}
	if i.NameIDNEQ != nil {
		predicates = append(predicates, manga.NameIDNEQ(*i.NameIDNEQ))
	}
	if len(i.NameIDIn) > 0 {
		predicates = append(predicates, manga.NameIDIn(i.NameIDIn...))
	}
	if len(i.NameIDNotIn) > 0 {
		predicates = append(predicates, manga.NameIDNotIn(i.NameIDNotIn...))
	}
	if i.NameIDGT != nil {
		predicates = append(predicates, manga.NameIDGT(*i.NameIDGT))
	}
	if i.NameIDGTE != nil {
		predicates = append(predicates, manga.NameIDGTE(*i.NameIDGTE))
	}
	if i.NameIDLT != nil {
		predicates = append(predicates, manga.NameIDLT(*i.NameIDLT))
	}
	if i.NameIDLTE != nil {
		predicates = append(predicates, manga.NameIDLTE(*i.NameIDLTE))
	}
	if i.NameIDContains != nil {
		predicates = append(predicates, manga.NameIDContains(*i.NameIDContains))
	}
	if i.NameIDHasPrefix != nil {
		predicates = append(predicates, manga.NameIDHasPrefix(*i.NameIDHasPrefix))
	}
	if i.NameIDHasSuffix != nil {
		predicates = append(predicates, manga.NameIDHasSuffix(*i.NameIDHasSuffix))
	}
	if i.NameIDEqualFold != nil {
		predicates = append(predicates, manga.NameIDEqualFold(*i.NameIDEqualFold))
	}
	if i.NameIDContainsFold != nil {
		predicates = append(predicates, manga.NameIDContainsFold(*i.NameIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, manga.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, manga.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, manga.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, manga.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, manga.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, manga.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, manga.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, manga.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, manga.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, manga.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, manga.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, manga.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, manga.NameContainsFold(*i.NameContainsFold))
	}
	if i.Desc != nil {
		predicates = append(predicates, manga.DescEQ(*i.Desc))
	}
	if i.DescNEQ != nil {
		predicates = append(predicates, manga.DescNEQ(*i.DescNEQ))
	}
	if len(i.DescIn) > 0 {
		predicates = append(predicates, manga.DescIn(i.DescIn...))
	}
	if len(i.DescNotIn) > 0 {
		predicates = append(predicates, manga.DescNotIn(i.DescNotIn...))
	}
	if i.DescGT != nil {
		predicates = append(predicates, manga.DescGT(*i.DescGT))
	}
	if i.DescGTE != nil {
		predicates = append(predicates, manga.DescGTE(*i.DescGTE))
	}
	if i.DescLT != nil {
		predicates = append(predicates, manga.DescLT(*i.DescLT))
	}
	if i.DescLTE != nil {
		predicates = append(predicates, manga.DescLTE(*i.DescLTE))
	}
	if i.DescContains != nil {
		predicates = append(predicates, manga.DescContains(*i.DescContains))
	}
	if i.DescHasPrefix != nil {
		predicates = append(predicates, manga.DescHasPrefix(*i.DescHasPrefix))
	}
	if i.DescHasSuffix != nil {
		predicates = append(predicates, manga.DescHasSuffix(*i.DescHasSuffix))
	}
	if i.DescEqualFold != nil {
		predicates = append(predicates, manga.DescEqualFold(*i.DescEqualFold))
	}
	if i.DescContainsFold != nil {
		predicates = append(predicates, manga.DescContainsFold(*i.DescContainsFold))
	}
	if i.Prodiver != nil {
		predicates = append(predicates, manga.ProdiverEQ(*i.Prodiver))
	}
	if i.ProdiverNEQ != nil {
		predicates = append(predicates, manga.ProdiverNEQ(*i.ProdiverNEQ))
	}
	if len(i.ProdiverIn) > 0 {
		predicates = append(predicates, manga.ProdiverIn(i.ProdiverIn...))
	}
	if len(i.ProdiverNotIn) > 0 {
		predicates = append(predicates, manga.ProdiverNotIn(i.ProdiverNotIn...))
	}
	if i.ProdiverGT != nil {
		predicates = append(predicates, manga.ProdiverGT(*i.ProdiverGT))
	}
	if i.ProdiverGTE != nil {
		predicates = append(predicates, manga.ProdiverGTE(*i.ProdiverGTE))
	}
	if i.ProdiverLT != nil {
		predicates = append(predicates, manga.ProdiverLT(*i.ProdiverLT))
	}
	if i.ProdiverLTE != nil {
		predicates = append(predicates, manga.ProdiverLTE(*i.ProdiverLTE))
	}
	if i.ProdiverContains != nil {
		predicates = append(predicates, manga.ProdiverContains(*i.ProdiverContains))
	}
	if i.ProdiverHasPrefix != nil {
		predicates = append(predicates, manga.ProdiverHasPrefix(*i.ProdiverHasPrefix))
	}
	if i.ProdiverHasSuffix != nil {
		predicates = append(predicates, manga.ProdiverHasSuffix(*i.ProdiverHasSuffix))
	}
	if i.ProdiverEqualFold != nil {
		predicates = append(predicates, manga.ProdiverEqualFold(*i.ProdiverEqualFold))
	}
	if i.ProdiverContainsFold != nil {
		predicates = append(predicates, manga.ProdiverContainsFold(*i.ProdiverContainsFold))
	}
	if i.ThumbnailURL != nil {
		predicates = append(predicates, manga.ThumbnailURLEQ(*i.ThumbnailURL))
	}
	if i.ThumbnailURLNEQ != nil {
		predicates = append(predicates, manga.ThumbnailURLNEQ(*i.ThumbnailURLNEQ))
	}
	if len(i.ThumbnailURLIn) > 0 {
		predicates = append(predicates, manga.ThumbnailURLIn(i.ThumbnailURLIn...))
	}
	if len(i.ThumbnailURLNotIn) > 0 {
		predicates = append(predicates, manga.ThumbnailURLNotIn(i.ThumbnailURLNotIn...))
	}
	if i.ThumbnailURLGT != nil {
		predicates = append(predicates, manga.ThumbnailURLGT(*i.ThumbnailURLGT))
	}
	if i.ThumbnailURLGTE != nil {
		predicates = append(predicates, manga.ThumbnailURLGTE(*i.ThumbnailURLGTE))
	}
	if i.ThumbnailURLLT != nil {
		predicates = append(predicates, manga.ThumbnailURLLT(*i.ThumbnailURLLT))
	}
	if i.ThumbnailURLLTE != nil {
		predicates = append(predicates, manga.ThumbnailURLLTE(*i.ThumbnailURLLTE))
	}
	if i.ThumbnailURLContains != nil {
		predicates = append(predicates, manga.ThumbnailURLContains(*i.ThumbnailURLContains))
	}
	if i.ThumbnailURLHasPrefix != nil {
		predicates = append(predicates, manga.ThumbnailURLHasPrefix(*i.ThumbnailURLHasPrefix))
	}
	if i.ThumbnailURLHasSuffix != nil {
		predicates = append(predicates, manga.ThumbnailURLHasSuffix(*i.ThumbnailURLHasSuffix))
	}
	if i.ThumbnailURLEqualFold != nil {
		predicates = append(predicates, manga.ThumbnailURLEqualFold(*i.ThumbnailURLEqualFold))
	}
	if i.ThumbnailURLContainsFold != nil {
		predicates = append(predicates, manga.ThumbnailURLContainsFold(*i.ThumbnailURLContainsFold))
	}

	if i.HasChapters != nil {
		p := manga.HasChapters()
		if !*i.HasChapters {
			p = manga.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChaptersWith) > 0 {
		with := make([]predicate.MangaChapter, 0, len(i.HasChaptersWith))
		for _, w := range i.HasChaptersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChaptersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, manga.HasChaptersWith(with...))
	}
	if i.HasGenres != nil {
		p := manga.HasGenres()
		if !*i.HasGenres {
			p = manga.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGenresWith) > 0 {
		with := make([]predicate.Genre, 0, len(i.HasGenresWith))
		for _, w := range i.HasGenresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGenresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, manga.HasGenresWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMangaWhereInput
	case 1:
		return predicates[0], nil
	default:
		return manga.And(predicates...), nil
	}
}

// MangaChapterWhereInput represents a where input for filtering MangaChapter queries.
type MangaChapterWhereInput struct {
	Predicates []predicate.MangaChapter  `json:"-"`
	Not        *MangaChapterWhereInput   `json:"not,omitempty"`
	Or         []*MangaChapterWhereInput `json:"or,omitempty"`
	And        []*MangaChapterWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pxid.ID  `json:"id,omitempty"`
	IDNEQ   *pxid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pxid.ID `json:"idIn,omitempty"`
	IDNotIn []pxid.ID `json:"idNotIn,omitempty"`
	IDGT    *pxid.ID  `json:"idGT,omitempty"`
	IDGTE   *pxid.ID  `json:"idGTE,omitempty"`
	IDLT    *pxid.ID  `json:"idLT,omitempty"`
	IDLTE   *pxid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "manga_id" field predicates.
	MangaID             *pxid.ID  `json:"mangaID,omitempty"`
	MangaIDNEQ          *pxid.ID  `json:"mangaIDNEQ,omitempty"`
	MangaIDIn           []pxid.ID `json:"mangaIDIn,omitempty"`
	MangaIDNotIn        []pxid.ID `json:"mangaIDNotIn,omitempty"`
	MangaIDGT           *pxid.ID  `json:"mangaIDGT,omitempty"`
	MangaIDGTE          *pxid.ID  `json:"mangaIDGTE,omitempty"`
	MangaIDLT           *pxid.ID  `json:"mangaIDLT,omitempty"`
	MangaIDLTE          *pxid.ID  `json:"mangaIDLTE,omitempty"`
	MangaIDContains     *pxid.ID  `json:"mangaIDContains,omitempty"`
	MangaIDHasPrefix    *pxid.ID  `json:"mangaIDHasPrefix,omitempty"`
	MangaIDHasSuffix    *pxid.ID  `json:"mangaIDHasSuffix,omitempty"`
	MangaIDEqualFold    *pxid.ID  `json:"mangaIDEqualFold,omitempty"`
	MangaIDContainsFold *pxid.ID  `json:"mangaIDContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "img_url" field predicates.
	ImgURL             *string  `json:"imgURL,omitempty"`
	ImgURLNEQ          *string  `json:"imgURLNEQ,omitempty"`
	ImgURLIn           []string `json:"imgURLIn,omitempty"`
	ImgURLNotIn        []string `json:"imgURLNotIn,omitempty"`
	ImgURLGT           *string  `json:"imgURLGT,omitempty"`
	ImgURLGTE          *string  `json:"imgURLGTE,omitempty"`
	ImgURLLT           *string  `json:"imgURLLT,omitempty"`
	ImgURLLTE          *string  `json:"imgURLLTE,omitempty"`
	ImgURLContains     *string  `json:"imgURLContains,omitempty"`
	ImgURLHasPrefix    *string  `json:"imgURLHasPrefix,omitempty"`
	ImgURLHasSuffix    *string  `json:"imgURLHasSuffix,omitempty"`
	ImgURLEqualFold    *string  `json:"imgURLEqualFold,omitempty"`
	ImgURLContainsFold *string  `json:"imgURLContainsFold,omitempty"`

	// "number" field predicates.
	Number      *uint  `json:"number,omitempty"`
	NumberNEQ   *uint  `json:"numberNEQ,omitempty"`
	NumberIn    []uint `json:"numberIn,omitempty"`
	NumberNotIn []uint `json:"numberNotIn,omitempty"`
	NumberGT    *uint  `json:"numberGT,omitempty"`
	NumberGTE   *uint  `json:"numberGTE,omitempty"`
	NumberLT    *uint  `json:"numberLT,omitempty"`
	NumberLTE   *uint  `json:"numberLTE,omitempty"`

	// "provider_name" field predicates.
	ProviderName             *string  `json:"providerName,omitempty"`
	ProviderNameNEQ          *string  `json:"providerNameNEQ,omitempty"`
	ProviderNameIn           []string `json:"providerNameIn,omitempty"`
	ProviderNameNotIn        []string `json:"providerNameNotIn,omitempty"`
	ProviderNameGT           *string  `json:"providerNameGT,omitempty"`
	ProviderNameGTE          *string  `json:"providerNameGTE,omitempty"`
	ProviderNameLT           *string  `json:"providerNameLT,omitempty"`
	ProviderNameLTE          *string  `json:"providerNameLTE,omitempty"`
	ProviderNameContains     *string  `json:"providerNameContains,omitempty"`
	ProviderNameHasPrefix    *string  `json:"providerNameHasPrefix,omitempty"`
	ProviderNameHasSuffix    *string  `json:"providerNameHasSuffix,omitempty"`
	ProviderNameEqualFold    *string  `json:"providerNameEqualFold,omitempty"`
	ProviderNameContainsFold *string  `json:"providerNameContainsFold,omitempty"`

	// "chapter_updated_at" field predicates.
	ChapterUpdatedAt      *time.Time  `json:"chapterUpdatedAt,omitempty"`
	ChapterUpdatedAtNEQ   *time.Time  `json:"chapterUpdatedAtNEQ,omitempty"`
	ChapterUpdatedAtIn    []time.Time `json:"chapterUpdatedAtIn,omitempty"`
	ChapterUpdatedAtNotIn []time.Time `json:"chapterUpdatedAtNotIn,omitempty"`
	ChapterUpdatedAtGT    *time.Time  `json:"chapterUpdatedAtGT,omitempty"`
	ChapterUpdatedAtGTE   *time.Time  `json:"chapterUpdatedAtGTE,omitempty"`
	ChapterUpdatedAtLT    *time.Time  `json:"chapterUpdatedAtLT,omitempty"`
	ChapterUpdatedAtLTE   *time.Time  `json:"chapterUpdatedAtLTE,omitempty"`

	// "manga" edge predicates.
	HasManga     *bool              `json:"hasManga,omitempty"`
	HasMangaWith []*MangaWhereInput `json:"hasMangaWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MangaChapterWhereInput) AddPredicates(predicates ...predicate.MangaChapter) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MangaChapterWhereInput filter on the MangaChapterQuery builder.
func (i *MangaChapterWhereInput) Filter(q *MangaChapterQuery) (*MangaChapterQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMangaChapterWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMangaChapterWhereInput is returned in case the MangaChapterWhereInput is empty.
var ErrEmptyMangaChapterWhereInput = errors.New("ent: empty predicate MangaChapterWhereInput")

// P returns a predicate for filtering mangachapters.
// An error is returned if the input is empty or invalid.
func (i *MangaChapterWhereInput) P() (predicate.MangaChapter, error) {
	var predicates []predicate.MangaChapter
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, mangachapter.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MangaChapter, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, mangachapter.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MangaChapter, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, mangachapter.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, mangachapter.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, mangachapter.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, mangachapter.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, mangachapter.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, mangachapter.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, mangachapter.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, mangachapter.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, mangachapter.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, mangachapter.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, mangachapter.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, mangachapter.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, mangachapter.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, mangachapter.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, mangachapter.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, mangachapter.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, mangachapter.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, mangachapter.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, mangachapter.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, mangachapter.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, mangachapter.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, mangachapter.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, mangachapter.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, mangachapter.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, mangachapter.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.MangaID != nil {
		predicates = append(predicates, mangachapter.MangaIDEQ(*i.MangaID))
	}
	if i.MangaIDNEQ != nil {
		predicates = append(predicates, mangachapter.MangaIDNEQ(*i.MangaIDNEQ))
	}
	if len(i.MangaIDIn) > 0 {
		predicates = append(predicates, mangachapter.MangaIDIn(i.MangaIDIn...))
	}
	if len(i.MangaIDNotIn) > 0 {
		predicates = append(predicates, mangachapter.MangaIDNotIn(i.MangaIDNotIn...))
	}
	if i.MangaIDGT != nil {
		predicates = append(predicates, mangachapter.MangaIDGT(*i.MangaIDGT))
	}
	if i.MangaIDGTE != nil {
		predicates = append(predicates, mangachapter.MangaIDGTE(*i.MangaIDGTE))
	}
	if i.MangaIDLT != nil {
		predicates = append(predicates, mangachapter.MangaIDLT(*i.MangaIDLT))
	}
	if i.MangaIDLTE != nil {
		predicates = append(predicates, mangachapter.MangaIDLTE(*i.MangaIDLTE))
	}
	if i.MangaIDContains != nil {
		predicates = append(predicates, mangachapter.MangaIDContains(*i.MangaIDContains))
	}
	if i.MangaIDHasPrefix != nil {
		predicates = append(predicates, mangachapter.MangaIDHasPrefix(*i.MangaIDHasPrefix))
	}
	if i.MangaIDHasSuffix != nil {
		predicates = append(predicates, mangachapter.MangaIDHasSuffix(*i.MangaIDHasSuffix))
	}
	if i.MangaIDEqualFold != nil {
		predicates = append(predicates, mangachapter.MangaIDEqualFold(*i.MangaIDEqualFold))
	}
	if i.MangaIDContainsFold != nil {
		predicates = append(predicates, mangachapter.MangaIDContainsFold(*i.MangaIDContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, mangachapter.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, mangachapter.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, mangachapter.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, mangachapter.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, mangachapter.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, mangachapter.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, mangachapter.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, mangachapter.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, mangachapter.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, mangachapter.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, mangachapter.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, mangachapter.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, mangachapter.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.ImgURL != nil {
		predicates = append(predicates, mangachapter.ImgURLEQ(*i.ImgURL))
	}
	if i.ImgURLNEQ != nil {
		predicates = append(predicates, mangachapter.ImgURLNEQ(*i.ImgURLNEQ))
	}
	if len(i.ImgURLIn) > 0 {
		predicates = append(predicates, mangachapter.ImgURLIn(i.ImgURLIn...))
	}
	if len(i.ImgURLNotIn) > 0 {
		predicates = append(predicates, mangachapter.ImgURLNotIn(i.ImgURLNotIn...))
	}
	if i.ImgURLGT != nil {
		predicates = append(predicates, mangachapter.ImgURLGT(*i.ImgURLGT))
	}
	if i.ImgURLGTE != nil {
		predicates = append(predicates, mangachapter.ImgURLGTE(*i.ImgURLGTE))
	}
	if i.ImgURLLT != nil {
		predicates = append(predicates, mangachapter.ImgURLLT(*i.ImgURLLT))
	}
	if i.ImgURLLTE != nil {
		predicates = append(predicates, mangachapter.ImgURLLTE(*i.ImgURLLTE))
	}
	if i.ImgURLContains != nil {
		predicates = append(predicates, mangachapter.ImgURLContains(*i.ImgURLContains))
	}
	if i.ImgURLHasPrefix != nil {
		predicates = append(predicates, mangachapter.ImgURLHasPrefix(*i.ImgURLHasPrefix))
	}
	if i.ImgURLHasSuffix != nil {
		predicates = append(predicates, mangachapter.ImgURLHasSuffix(*i.ImgURLHasSuffix))
	}
	if i.ImgURLEqualFold != nil {
		predicates = append(predicates, mangachapter.ImgURLEqualFold(*i.ImgURLEqualFold))
	}
	if i.ImgURLContainsFold != nil {
		predicates = append(predicates, mangachapter.ImgURLContainsFold(*i.ImgURLContainsFold))
	}
	if i.Number != nil {
		predicates = append(predicates, mangachapter.NumberEQ(*i.Number))
	}
	if i.NumberNEQ != nil {
		predicates = append(predicates, mangachapter.NumberNEQ(*i.NumberNEQ))
	}
	if len(i.NumberIn) > 0 {
		predicates = append(predicates, mangachapter.NumberIn(i.NumberIn...))
	}
	if len(i.NumberNotIn) > 0 {
		predicates = append(predicates, mangachapter.NumberNotIn(i.NumberNotIn...))
	}
	if i.NumberGT != nil {
		predicates = append(predicates, mangachapter.NumberGT(*i.NumberGT))
	}
	if i.NumberGTE != nil {
		predicates = append(predicates, mangachapter.NumberGTE(*i.NumberGTE))
	}
	if i.NumberLT != nil {
		predicates = append(predicates, mangachapter.NumberLT(*i.NumberLT))
	}
	if i.NumberLTE != nil {
		predicates = append(predicates, mangachapter.NumberLTE(*i.NumberLTE))
	}
	if i.ProviderName != nil {
		predicates = append(predicates, mangachapter.ProviderNameEQ(*i.ProviderName))
	}
	if i.ProviderNameNEQ != nil {
		predicates = append(predicates, mangachapter.ProviderNameNEQ(*i.ProviderNameNEQ))
	}
	if len(i.ProviderNameIn) > 0 {
		predicates = append(predicates, mangachapter.ProviderNameIn(i.ProviderNameIn...))
	}
	if len(i.ProviderNameNotIn) > 0 {
		predicates = append(predicates, mangachapter.ProviderNameNotIn(i.ProviderNameNotIn...))
	}
	if i.ProviderNameGT != nil {
		predicates = append(predicates, mangachapter.ProviderNameGT(*i.ProviderNameGT))
	}
	if i.ProviderNameGTE != nil {
		predicates = append(predicates, mangachapter.ProviderNameGTE(*i.ProviderNameGTE))
	}
	if i.ProviderNameLT != nil {
		predicates = append(predicates, mangachapter.ProviderNameLT(*i.ProviderNameLT))
	}
	if i.ProviderNameLTE != nil {
		predicates = append(predicates, mangachapter.ProviderNameLTE(*i.ProviderNameLTE))
	}
	if i.ProviderNameContains != nil {
		predicates = append(predicates, mangachapter.ProviderNameContains(*i.ProviderNameContains))
	}
	if i.ProviderNameHasPrefix != nil {
		predicates = append(predicates, mangachapter.ProviderNameHasPrefix(*i.ProviderNameHasPrefix))
	}
	if i.ProviderNameHasSuffix != nil {
		predicates = append(predicates, mangachapter.ProviderNameHasSuffix(*i.ProviderNameHasSuffix))
	}
	if i.ProviderNameEqualFold != nil {
		predicates = append(predicates, mangachapter.ProviderNameEqualFold(*i.ProviderNameEqualFold))
	}
	if i.ProviderNameContainsFold != nil {
		predicates = append(predicates, mangachapter.ProviderNameContainsFold(*i.ProviderNameContainsFold))
	}
	if i.ChapterUpdatedAt != nil {
		predicates = append(predicates, mangachapter.ChapterUpdatedAtEQ(*i.ChapterUpdatedAt))
	}
	if i.ChapterUpdatedAtNEQ != nil {
		predicates = append(predicates, mangachapter.ChapterUpdatedAtNEQ(*i.ChapterUpdatedAtNEQ))
	}
	if len(i.ChapterUpdatedAtIn) > 0 {
		predicates = append(predicates, mangachapter.ChapterUpdatedAtIn(i.ChapterUpdatedAtIn...))
	}
	if len(i.ChapterUpdatedAtNotIn) > 0 {
		predicates = append(predicates, mangachapter.ChapterUpdatedAtNotIn(i.ChapterUpdatedAtNotIn...))
	}
	if i.ChapterUpdatedAtGT != nil {
		predicates = append(predicates, mangachapter.ChapterUpdatedAtGT(*i.ChapterUpdatedAtGT))
	}
	if i.ChapterUpdatedAtGTE != nil {
		predicates = append(predicates, mangachapter.ChapterUpdatedAtGTE(*i.ChapterUpdatedAtGTE))
	}
	if i.ChapterUpdatedAtLT != nil {
		predicates = append(predicates, mangachapter.ChapterUpdatedAtLT(*i.ChapterUpdatedAtLT))
	}
	if i.ChapterUpdatedAtLTE != nil {
		predicates = append(predicates, mangachapter.ChapterUpdatedAtLTE(*i.ChapterUpdatedAtLTE))
	}

	if i.HasManga != nil {
		p := mangachapter.HasManga()
		if !*i.HasManga {
			p = mangachapter.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMangaWith) > 0 {
		with := make([]predicate.Manga, 0, len(i.HasMangaWith))
		for _, w := range i.HasMangaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMangaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mangachapter.HasMangaWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMangaChapterWhereInput
	case 1:
		return predicates[0], nil
	default:
		return mangachapter.And(predicates...), nil
	}
}

// PermissionWhereInput represents a where input for filtering Permission queries.
type PermissionWhereInput struct {
	Predicates []predicate.Permission  `json:"-"`
	Not        *PermissionWhereInput   `json:"not,omitempty"`
	Or         []*PermissionWhereInput `json:"or,omitempty"`
	And        []*PermissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pxid.ID  `json:"id,omitempty"`
	IDNEQ   *pxid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pxid.ID `json:"idIn,omitempty"`
	IDNotIn []pxid.ID `json:"idNotIn,omitempty"`
	IDGT    *pxid.ID  `json:"idGT,omitempty"`
	IDGTE   *pxid.ID  `json:"idGTE,omitempty"`
	IDLT    *pxid.ID  `json:"idLT,omitempty"`
	IDLTE   *pxid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "group" field predicates.
	Group             *string  `json:"group,omitempty"`
	GroupNEQ          *string  `json:"groupNEQ,omitempty"`
	GroupIn           []string `json:"groupIn,omitempty"`
	GroupNotIn        []string `json:"groupNotIn,omitempty"`
	GroupGT           *string  `json:"groupGT,omitempty"`
	GroupGTE          *string  `json:"groupGTE,omitempty"`
	GroupLT           *string  `json:"groupLT,omitempty"`
	GroupLTE          *string  `json:"groupLTE,omitempty"`
	GroupContains     *string  `json:"groupContains,omitempty"`
	GroupHasPrefix    *string  `json:"groupHasPrefix,omitempty"`
	GroupHasSuffix    *string  `json:"groupHasSuffix,omitempty"`
	GroupEqualFold    *string  `json:"groupEqualFold,omitempty"`
	GroupContainsFold *string  `json:"groupContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "scope" field predicates.
	Scope             *string  `json:"scope,omitempty"`
	ScopeNEQ          *string  `json:"scopeNEQ,omitempty"`
	ScopeIn           []string `json:"scopeIn,omitempty"`
	ScopeNotIn        []string `json:"scopeNotIn,omitempty"`
	ScopeGT           *string  `json:"scopeGT,omitempty"`
	ScopeGTE          *string  `json:"scopeGTE,omitempty"`
	ScopeLT           *string  `json:"scopeLT,omitempty"`
	ScopeLTE          *string  `json:"scopeLTE,omitempty"`
	ScopeContains     *string  `json:"scopeContains,omitempty"`
	ScopeHasPrefix    *string  `json:"scopeHasPrefix,omitempty"`
	ScopeHasSuffix    *string  `json:"scopeHasSuffix,omitempty"`
	ScopeEqualFold    *string  `json:"scopeEqualFold,omitempty"`
	ScopeContainsFold *string  `json:"scopeContainsFold,omitempty"`

	// "type" field predicates.
	Type       *permission.Type  `json:"type,omitempty"`
	TypeNEQ    *permission.Type  `json:"typeNEQ,omitempty"`
	TypeIn     []permission.Type `json:"typeIn,omitempty"`
	TypeNotIn  []permission.Type `json:"typeNotIn,omitempty"`
	TypeIsNil  bool              `json:"typeIsNil,omitempty"`
	TypeNotNil bool              `json:"typeNotNil,omitempty"`

	// "order" field predicates.
	Order       *int  `json:"order,omitempty"`
	OrderNEQ    *int  `json:"orderNEQ,omitempty"`
	OrderIn     []int `json:"orderIn,omitempty"`
	OrderNotIn  []int `json:"orderNotIn,omitempty"`
	OrderGT     *int  `json:"orderGT,omitempty"`
	OrderGTE    *int  `json:"orderGTE,omitempty"`
	OrderLT     *int  `json:"orderLT,omitempty"`
	OrderLTE    *int  `json:"orderLTE,omitempty"`
	OrderIsNil  bool  `json:"orderIsNil,omitempty"`
	OrderNotNil bool  `json:"orderNotNil,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PermissionWhereInput) AddPredicates(predicates ...predicate.Permission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PermissionWhereInput filter on the PermissionQuery builder.
func (i *PermissionWhereInput) Filter(q *PermissionQuery) (*PermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPermissionWhereInput is returned in case the PermissionWhereInput is empty.
var ErrEmptyPermissionWhereInput = errors.New("ent: empty predicate PermissionWhereInput")

// P returns a predicate for filtering permissions.
// An error is returned if the input is empty or invalid.
func (i *PermissionWhereInput) P() (predicate.Permission, error) {
	var predicates []predicate.Permission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, permission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Permission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, permission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Permission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, permission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, permission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, permission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, permission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, permission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, permission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, permission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, permission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, permission.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, permission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, permission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, permission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, permission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, permission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, permission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, permission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, permission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, permission.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, permission.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, permission.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, permission.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, permission.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, permission.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Group != nil {
		predicates = append(predicates, permission.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, permission.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, permission.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, permission.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, permission.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, permission.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, permission.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, permission.GroupLTE(*i.GroupLTE))
	}
	if i.GroupContains != nil {
		predicates = append(predicates, permission.GroupContains(*i.GroupContains))
	}
	if i.GroupHasPrefix != nil {
		predicates = append(predicates, permission.GroupHasPrefix(*i.GroupHasPrefix))
	}
	if i.GroupHasSuffix != nil {
		predicates = append(predicates, permission.GroupHasSuffix(*i.GroupHasSuffix))
	}
	if i.GroupEqualFold != nil {
		predicates = append(predicates, permission.GroupEqualFold(*i.GroupEqualFold))
	}
	if i.GroupContainsFold != nil {
		predicates = append(predicates, permission.GroupContainsFold(*i.GroupContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, permission.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, permission.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, permission.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, permission.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, permission.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, permission.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, permission.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, permission.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, permission.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, permission.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, permission.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, permission.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, permission.NameContainsFold(*i.NameContainsFold))
	}
	if i.Scope != nil {
		predicates = append(predicates, permission.ScopeEQ(*i.Scope))
	}
	if i.ScopeNEQ != nil {
		predicates = append(predicates, permission.ScopeNEQ(*i.ScopeNEQ))
	}
	if len(i.ScopeIn) > 0 {
		predicates = append(predicates, permission.ScopeIn(i.ScopeIn...))
	}
	if len(i.ScopeNotIn) > 0 {
		predicates = append(predicates, permission.ScopeNotIn(i.ScopeNotIn...))
	}
	if i.ScopeGT != nil {
		predicates = append(predicates, permission.ScopeGT(*i.ScopeGT))
	}
	if i.ScopeGTE != nil {
		predicates = append(predicates, permission.ScopeGTE(*i.ScopeGTE))
	}
	if i.ScopeLT != nil {
		predicates = append(predicates, permission.ScopeLT(*i.ScopeLT))
	}
	if i.ScopeLTE != nil {
		predicates = append(predicates, permission.ScopeLTE(*i.ScopeLTE))
	}
	if i.ScopeContains != nil {
		predicates = append(predicates, permission.ScopeContains(*i.ScopeContains))
	}
	if i.ScopeHasPrefix != nil {
		predicates = append(predicates, permission.ScopeHasPrefix(*i.ScopeHasPrefix))
	}
	if i.ScopeHasSuffix != nil {
		predicates = append(predicates, permission.ScopeHasSuffix(*i.ScopeHasSuffix))
	}
	if i.ScopeEqualFold != nil {
		predicates = append(predicates, permission.ScopeEqualFold(*i.ScopeEqualFold))
	}
	if i.ScopeContainsFold != nil {
		predicates = append(predicates, permission.ScopeContainsFold(*i.ScopeContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, permission.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, permission.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, permission.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, permission.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeIsNil {
		predicates = append(predicates, permission.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, permission.TypeNotNil())
	}
	if i.Order != nil {
		predicates = append(predicates, permission.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, permission.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, permission.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, permission.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, permission.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, permission.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, permission.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, permission.OrderLTE(*i.OrderLTE))
	}
	if i.OrderIsNil {
		predicates = append(predicates, permission.OrderIsNil())
	}
	if i.OrderNotNil {
		predicates = append(predicates, permission.OrderNotNil())
	}

	if i.HasRoles != nil {
		p := permission.HasRoles()
		if !*i.HasRoles {
			p = permission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, permission.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return permission.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pxid.ID  `json:"id,omitempty"`
	IDNEQ   *pxid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pxid.ID `json:"idIn,omitempty"`
	IDNotIn []pxid.ID `json:"idNotIn,omitempty"`
	IDGT    *pxid.ID  `json:"idGT,omitempty"`
	IDGTE   *pxid.ID  `json:"idGTE,omitempty"`
	IDLT    *pxid.ID  `json:"idLT,omitempty"`
	IDLTE   *pxid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "is_enable" field predicates.
	IsEnable    *bool `json:"isEnable,omitempty"`
	IsEnableNEQ *bool `json:"isEnableNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "is_changeable" field predicates.
	IsChangeable    *bool `json:"isChangeable,omitempty"`
	IsChangeableNEQ *bool `json:"isChangeableNEQ,omitempty"`

	// "admins" edge predicates.
	HasAdmins     *bool              `json:"hasAdmins,omitempty"`
	HasAdminsWith []*AdminWhereInput `json:"hasAdminsWith,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, role.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, role.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, role.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, role.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, role.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, role.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, role.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, role.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.IsEnable != nil {
		predicates = append(predicates, role.IsEnableEQ(*i.IsEnable))
	}
	if i.IsEnableNEQ != nil {
		predicates = append(predicates, role.IsEnableNEQ(*i.IsEnableNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, role.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, role.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, role.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, role.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, role.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, role.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, role.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, role.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, role.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, role.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, role.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, role.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, role.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, role.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, role.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, role.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, role.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, role.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, role.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, role.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, role.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, role.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, role.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, role.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, role.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, role.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, role.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, role.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, role.OrderLTE(*i.OrderLTE))
	}
	if i.IsChangeable != nil {
		predicates = append(predicates, role.IsChangeableEQ(*i.IsChangeable))
	}
	if i.IsChangeableNEQ != nil {
		predicates = append(predicates, role.IsChangeableNEQ(*i.IsChangeableNEQ))
	}

	if i.HasAdmins != nil {
		p := role.HasAdmins()
		if !*i.HasAdmins {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAdminsWith) > 0 {
		with := make([]predicate.Admin, 0, len(i.HasAdminsWith))
		for _, w := range i.HasAdminsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAdminsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasAdminsWith(with...))
	}
	if i.HasPermissions != nil {
		p := role.HasPermissions()
		if !*i.HasPermissions {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasPermissionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}
